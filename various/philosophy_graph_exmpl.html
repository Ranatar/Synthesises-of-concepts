<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–†–∞—Å—à–∏—Ä–µ–Ω–Ω—ã–π –≥—Ä–∞—Ñ —Ñ–∏–ª–æ—Å–æ—Ñ—Å–∫–∏—Ö –∫–æ–Ω—Ü–µ–ø—Ü–∏–π</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0f0c29 0%, #302b63 50%, #24243e 100%);
            overflow: hidden;
        }

        #container {
            width: 100vw;
            height: 100vh;
            position: relative;
        }

        #graph {
            width: 100%;
            height: 100%;
        }

        .node {
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .node:hover {
            filter: brightness(1.3);
        }

        .node circle {
            stroke-width: 3px;
            filter: drop-shadow(0 0 10px rgba(255,255,255,0.4));
        }

        .node.dimmed {
            opacity: 0.2;
        }

        .node.highlighted {
            opacity: 1;
        }

        .node.highlighted circle {
            stroke-width: 5px;
            filter: drop-shadow(0 0 20px rgba(255,255,255,0.8));
        }

        .node.selected circle {
            stroke-width: 6px;
            stroke: #ffd700 !important;
            filter: drop-shadow(0 0 15px #ffd700);
        }

        .node text {
            font-size: 10px;
            font-weight: 600;
            pointer-events: none;
            text-shadow: 0 0 4px black, 0 0 4px black, 0 0 4px black;
            fill: #fff;
        }

        .link {
            fill: none;
            stroke-width: 2px;
            opacity: 0.4;
            transition: opacity 0.3s, stroke-width 0.3s;
        }

        .link:hover {
            opacity: 0.9;
            stroke-width: 3.5px;
        }

        .link.dimmed {
            opacity: 0.1;
        }

        .link.highlighted {
            opacity: 1;
            stroke-width: 4px;
            filter: drop-shadow(0 0 5px currentColor);
        }

        .link.bidirectional {
            stroke-dasharray: 5, 5;
        }

        #legend {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.97);
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.4);
            max-width: 340px;
            backdrop-filter: blur(10px);
            max-height: 85vh;
            overflow-y: auto;
        }
        
        #legend h3 {
            margin: 0 0 15px 0;
            color: #1a1a2e;
            font-size: 19px;
            border-bottom: 3px solid #6c5ce7;
            padding-bottom: 10px;
        }
        
        .legend-section {
            margin-bottom: 18px;
        }
        
        .legend-section h4 {
            margin: 0 0 10px 0;
            color: #2d3436;
            font-size: 13px;
            font-weight: 700;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        /* –°—Ç–∏–ª–∏ –¥–ª—è radio buttons */
        .legend-item input[type="radio"] {
            margin-right: 8px;
            cursor: pointer;
            width: 16px;
            height: 16px;
            accent-color: #6c5ce7;
        }
        
        .filter-controls {
            display: flex;
            gap: 5px;
            margin-bottom: 10px;
        }
        
        .filter-controls button {
            flex: 1;
            background: #95a5a6;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 10px;
            font-weight: 600;
            transition: background 0.3s;
        }
        
        .filter-controls button:hover {
            background: #7f8c8d;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            margin: 6px 0;
            padding: 5px;
            border-radius: 5px;
            transition: background 0.2s;
            cursor: pointer;
        }
        
        .legend-item:hover {
            background: rgba(108, 92, 231, 0.1);
        }
        
        .legend-item input[type="checkbox"] {
            margin-right: 8px;
            cursor: pointer;
            width: 16px;
            height: 16px;
            accent-color: #6c5ce7;
        }
        
        .legend-item label {
            cursor: pointer;
            font-size: 11px;
            color: #2d3436;
            display: flex;
            align-items: center;
            flex-grow: 1;
        }
        
        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            margin-right: 10px;
            border: 2px solid #2d3436;
            flex-shrink: 0;
        }
        
        .legend-line {
            width: 35px;
            height: 2.5px;
            margin-right: 10px;
            flex-shrink: 0;
        }
        
        .filter-stats {
            font-size: 10px;
            color: #7f8c8d;
            font-style: italic;
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid #e0e0e0;
        }
        
        #legend::-webkit-scrollbar {
            width: 6px;
        }
        
        #legend::-webkit-scrollbar-track {
            background: rgba(0,0,0,0.1);
            border-radius: 10px;
        }
        
        #legend::-webkit-scrollbar-thumb {
            background: #6c5ce7;
            border-radius: 10px;
        }

        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.92);
            color: white;
            padding: 12px 18px;
            border-radius: 10px;
            font-size: 13px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
            box-shadow: 0 6px 20px rgba(0,0,0,0.5);
            max-width: 280px;
            border: 1px solid rgba(255,255,255,0.2);
            z-index: 1000;
        }

        .tooltip strong {
            font-size: 15px;
            display: block;
            margin-bottom: 5px;
            color: #a29bfe;
        }

        #controls {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(255, 255, 255, 0.97);
            padding: 15px;
            border-radius: 12px;
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
        }

        #controls button {
            background: #6c5ce7;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 6px;
            cursor: pointer;
            margin: 3px;
            font-size: 12px;
            font-weight: 600;
            transition: background 0.3s;
        }

        #controls button:hover {
            background: #5f4fd1;
        }

        #controls button.active {
            background: #00b894;
        }

        #info {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.97);
            padding: 15px 20px;
            border-radius: 12px;
            font-size: 13px;
            color: #2d3436;
            box-shadow: 0 6px 20px rgba(0,0,0,0.3);
            font-weight: 500;
            //z-index: 1;
            transition: box-shadow 0.2s ease; /* –ü–ª–∞–≤–Ω—ã–π –ø–µ—Ä–µ—Ö–æ–¥ –¥–ª—è –≤–∏–∑—É–∞–ª—å–Ω–æ–≥–æ —ç—Ñ—Ñ–µ–∫—Ç–∞ */
        }
        
        #info:hover {
            z-index: 9999; /* –í—ã—Å–æ–∫–∏–π –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç –ø—Ä–∏ –Ω–∞–≤–µ–¥–µ–Ω–∏–∏ */
            box-shadow: 0 8px 25px rgba(0,0,0,0.4); /* –£—Å–∏–ª–µ–Ω–∏–µ —Ç–µ–Ω–∏ –¥–ª—è –≤–∏–∑—É–∞–ª—å–Ω–æ–≥–æ —ç—Ñ—Ñ–µ–∫—Ç–∞ */
        }
        
        #detailModal {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.92);
            color: white;
            padding: 25px 30px;
            border-radius: 15px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.7);
            max-width: 550px;
            max-height: 80vh;
            overflow-y: auto;
            z-index: 2000;
            border: 1px solid rgba(255,255,255,0.2);
        }
        
        #detailModal.show {
            display: block;
        }
        
        #modalOverlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 1999;
        }
        
        #modalOverlay.show {
            display: block;
        }
        
        #detailModal h2 {
            margin: 0 0 8px 0;
            color: #a29bfe;
            font-size: 22px;
            font-weight: 600;
        }
        
        #detailModal .philosopher-tag {
            display: inline-block;
            padding: 4px 10px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 600;
            color: white;
            margin-bottom: 12px;
            opacity: 0.9;
        }
        
        #detailModal .description {
            color: #e0e0e0;
            margin-bottom: 18px;
            line-height: 1.5;
            font-size: 13px;
        }
        
        #detailModal .rubric-section {
            background: rgba(255, 255, 255, 0.08);
            padding: 18px;
            border-radius: 10px;
            border-left: 3px solid #a29bfe;
        }
        
        #detailModal .rubric-title {
            font-size: 15px;
            font-weight: 700;
            color: #a29bfe;
            margin-bottom: 6px;
        }
        
        #detailModal .rubric-description {
            font-size: 12px;
            color: #b0b0b0;
            margin-bottom: 14px;
            font-style: italic;
        }
        
        #detailModal .related-concepts {
            margin-top: 12px;
        }
        
        #detailModal .related-title {
            font-size: 13px;
            font-weight: 700;
            color: #e0e0e0;
            margin-bottom: 8px;
        }
        
        #detailModal .concept-item {
            display: flex;
            align-items: center;
            padding: 7px 10px;
            margin: 4px 0;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        #detailModal .concept-item:hover {
            background: rgba(255, 255, 255, 0.15);
            transform: translateX(5px);
            border-color: rgba(162, 155, 254, 0.4);
        }
        
        #detailModal .concept-color {
            width: 11px;
            height: 11px;
            border-radius: 50%;
            margin-right: 10px;
            flex-shrink: 0;
            box-shadow: 0 0 8px currentColor;
        }
        
        #detailModal .concept-name {
            font-size: 13px;
            color: #e0e0e0;
            flex-grow: 1;
        }
        
        #detailModal .concept-philosopher {
            font-size: 10px;
            color: #a0a0a0;
            font-style: italic;
        }
        
        #detailModal .close-btn {
            position: absolute;
            top: 12px;
            right: 12px;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.15);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            cursor: pointer;
            font-size: 18px;
            line-height: 1;
            transition: all 0.2s;
        }
        
        #detailModal .close-btn:hover {
            background: rgba(255, 255, 255, 0.25);
            transform: rotate(90deg);
        }
        
        #detailModal::-webkit-scrollbar {
            width: 6px;
        }
        
        #detailModal::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 10px;
        }
        
        #detailModal::-webkit-scrollbar-thumb {
            background: #a29bfe;
            border-radius: 10px;
        }
        
        #detailModal::-webkit-scrollbar-thumb:hover {
            background: #8b7fe6;
        }
        
        /* –ü–∞–Ω–µ–ª—å –ø–æ–∏—Å–∫–∞ –ø—É—Ç–∏ - —Å –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å—é —Å–≤–æ—Ä–∞—á–∏–≤–∞–Ω–∏—è */
        #pathFinder {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.97);
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.4);
            max-width: 320px;
            backdrop-filter: blur(10px);
            z-index: 100;
            transition: all 0.3s ease;
        }
        
        #pathFinder.collapsed {
            max-width: 60px;
            padding: 10px;
        }
        
        #pathFinder.collapsed .panel-content {
            display: none;
        }
        
        #pathFinder h3 {
            margin: 0 0 15px 0;
            color: #1a1a2e;
            font-size: 17px;
            border-bottom: 3px solid #e74c3c;
            padding-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        #pathFinder.collapsed h3 {
            border-bottom: none;
            margin: 0;
            padding: 0;
        }
        
        .path-select-group {
            margin-bottom: 15px;
        }
        
        .path-select-group label {
            display: block;
            font-size: 12px;
            font-weight: 700;
            color: #2d3436;
            margin-bottom: 5px;
        }
        
        .path-select-group select {
            width: 100%;
            padding: 8px 10px;
            border: 2px solid #dfe6e9;
            border-radius: 8px;
            font-size: 12px;
            background: white;
            cursor: pointer;
            transition: border-color 0.3s;
        }
        
        .path-select-group select:focus {
            outline: none;
            border-color: #e74c3c;
        }
        
        #findPathBtn {
            width: 100%;
            background: #e74c3c;
            color: white;
            border: none;
            padding: 10px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 13px;
            font-weight: 600;
            transition: background 0.3s;
            margin-bottom: 10px;
        }
        
        #findPathBtn:hover {
            background: #c0392b;
        }
        
        #pathResult {
            margin-top: 15px;
            padding: 12px;
            background: rgba(231, 76, 60, 0.1);
            border-radius: 8px;
            border-left: 3px solid #e74c3c;
            display: none;
        }
        
        #pathResult.show {
            display: block;
        }
        
        #pathResult .path-length {
            font-size: 12px;
            font-weight: 700;
            color: #e74c3c;
            margin-bottom: 8px;
        }
        
        #pathResult .path-chain {
            font-size: 11px;
            color: #2d3436;
            line-height: 1.6;
        }
        
        #pathResult .path-node {
            display: inline-block;
            padding: 3px 8px;
            background: white;
            border-radius: 4px;
            margin: 2px;
            border: 1px solid #e74c3c;
        }
        
        #pathResult .path-arrow {
            color: #e74c3c;
            margin: 0 5px;
        }
        
        /* –ö–æ–Ω—Ç–µ–π–Ω–µ—Ä –¥–ª—è —É–∑–ª–∞ –ø—É—Ç–∏ —Å —Ñ–∏–ª–æ—Å–æ—Ñ–æ–º */
        .path-node-container {
            display: inline-flex;
            flex-direction: column;
            align-items: center;
            margin: 2px;
            vertical-align: middle;
        }
        
        .path-philosopher {
            font-size: 9px;
            color: #95a5a6;
            font-style: italic;
            margin-bottom: 2px;
            white-space: nowrap;
        }
        
        .path-node {
            display: inline-block;
            padding: 3px 8px;
            background: white;
            border-radius: 4px;
            margin: 0;
            border: 1px solid;
        }
        
        .path-arrow {
            display: inline-flex;
            align-items: center;
            margin: 0 5px;
            font-weight: bold;
            font-size: 14px;
            vertical-align: middle;
        }
        
        .path-arrow.bidirectional {
            font-size: 12px;
        }
        
        /* –ü–∞–Ω–µ–ª—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ - —Å –≤–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å—é —Å–≤–æ—Ä–∞—á–∏–≤–∞–Ω–∏—è */
        #statsPanel {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.97);
            padding: 20px;
            border-radius: 15px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.4);
            max-width: 320px;
            max-height: 450px;
            z-index: 1;
            overflow-y: auto;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
        }
        
        #statsPanel.collapsed {
            max-width: 60px;
            max-height: 60px;
            padding: 10px;
            overflow: hidden;
        }
        
        #statsPanel.collapsed .panel-content {
            display: none;
        }
        
        #statsPanel h3 {
            margin: 0 0 15px 0;
            color: #1a1a2e;
            font-size: 17px;
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        #statsPanel.collapsed h3 {
            border-bottom: none;
            margin: 0;
            padding: 0;
        }
        
        /* –ö–Ω–æ–ø–∫–∞ —Å–≤–æ—Ä–∞—á–∏–≤–∞–Ω–∏—è */
        .collapse-btn {
            background: rgba(0, 0, 0, 0.1);
            border: none;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            cursor: pointer;
            font-size: 14px;
            line-height: 1;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
        }
        
        .collapse-btn:hover {
            background: rgba(0, 0, 0, 0.2);
            transform: scale(1.1);
        }
        
        .collapsed .collapse-btn {
            width: 40px;
            height: 40px;
            font-size: 20px;
        }
        
        .stats-section {
            margin-bottom: 20px;
        }
        
        .stats-section h4 {
            font-size: 13px;
            font-weight: 700;
            color: #2d3436;
            margin: 0 0 10px 0;
        }
        
        .stat-item {
            display: flex;
            align-items: center;
            padding: 6px 8px;
            margin: 4px 0;
            background: rgba(52, 152, 219, 0.08);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .stat-item:hover {
            background: rgba(52, 152, 219, 0.18);
            transform: translateX(3px);
        }
        
        .stat-rank {
            font-size: 13px;
            font-weight: 700;
            color: #3498db;
            min-width: 25px;
        }
        
        .stat-name {
            flex-grow: 1;
            font-size: 11px;
            color: #2d3436;
        }
        
        .stat-value {
            font-size: 11px;
            font-weight: 600;
            color: #7f8c8d;
        }
        
        .stat-philosopher {
            font-size: 9px;
            color: #95a5a6;
            font-style: italic;
            margin-left: 5px;
        }
        
        #statsPanel::-webkit-scrollbar {
            width: 6px;
        }
        
        #statsPanel::-webkit-scrollbar-track {
            background: rgba(0,0,0,0.1);
            border-radius: 10px;
        }
        
        #statsPanel::-webkit-scrollbar-thumb {
            background: #3498db;
            border-radius: 10px;
        }
        
        /* –£–ª—É—á—à–µ–Ω–Ω—ã–µ —Å–≤—è–∑–∏ —Å –≤–µ—Å–∞–º–∏ */
        .link.weight-weak {
            stroke-width: 2px;
        }
        
        .link.weight-medium {
            stroke-width: 3px;
        }
        
        .link.weight-strong {
            stroke-width: 5px;
        }
        
        .link.path-highlight {
            stroke-width: 6px !important;
            opacity: 1 !important;
            filter: drop-shadow(0 0 8px currentColor);
            animation: pulse 1.5s ease-in-out infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }
        
        /* –°—Ç–∏–ª–∏ –¥–ª—è –≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏—Ö –ø—Ä–æ—Ç–∏–≤–æ—Ä–µ—á–∏–π */
        .link.internal-contradiction {
            stroke-dasharray: 8, 4;
            animation: dash 20s linear infinite;
        }
        
        @keyframes dash {
            to {
                stroke-dashoffset: -1000;
            }
        }
        
        /* –õ–µ–≥–µ–Ω–¥–∞ –≤–µ—Å–æ–≤ */
        .weight-legend {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid #e0e0e0;
        }
        
        .weight-item {
            display: flex;
            align-items: center;
            margin: 5px 0;
            font-size: 10px;
            color: #7f8c8d;
        }
        
        .weight-line {
            height: 2px;
            margin-right: 10px;
            background: #95a5a6;
            flex-shrink: 0;
        }
        
        .weight-line.weak { width: 20px; height: 2px; }
        .weight-line.medium { width: 20px; height: 3px; }
        .weight-line.strong { width: 20px; height: 5px; }
        
        /* –ü–ª–∞–≤–Ω–∞—è –∞–Ω–∏–º–∞—Ü–∏—è –¥–ª—è –∑–∞–≥–æ–ª–æ–≤–∫–æ–≤ –ø—Ä–∏ —Å–≤–æ—Ä–∞—á–∏–≤–∞–Ω–∏–∏ */
        .panel-title {
            transition: opacity 0.2s;
        }
        
        .collapsed .panel-title {
            opacity: 0;
            font-size: 0;
            overflow: hidden;
        }
        
        /* –ò–∫–æ–Ω–∫–∞ —Ä–∞–∑–≤–æ—Ä–∞—á–∏–≤–∞–Ω–∏—è –¥–ª—è —Å–≤–µ—Ä–Ω—É—Ç—ã—Ö –ø–∞–Ω–µ–ª–µ–π */
        .collapsed .collapse-btn .expand-icon {
            font-size: 24px;
            font-weight: bold;
        }
        
        /* –°—Ç–∏–ª–∏ –¥–ª—è —Ç–∞–±–æ–≤ –º–µ—Ç—Ä–∏–∫ */
        .metric-tabs {
            display: flex;
            gap: 3px;
            margin-bottom: 10px;
            flex-wrap: wrap;
        }
        
        .tab-btn {
            flex: 1;
            min-width: 70px;
            background: #ecf0f1;
            border: none;
            padding: 6px 4px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 10px;
            font-weight: 600;
            transition: background 0.2s;
            color: #2d3436;
        }
        
        .tab-btn:hover {
            background: #d5dbde;
        }
        
        .tab-btn.active {
            background: #3498db;
            color: white;
        }
        
        /* –°—Ç–∏–ª–∏ –¥–ª—è –ø—Ä–æ–≥—Ä–µ—Å—Å-–±–∞—Ä–∞ */
        #analysisProgress {
            display: none;
            margin-top: 15px;
            padding: 12px;
            background: rgba(52, 152, 219, 0.1);
            border-radius: 8px;
        }
        
        /* –°—Ç–∏–ª–∏ –¥–ª—è –±–ª–æ–∫–∞ –æ–ø–∏—Å–∞–Ω–∏—è –º–µ—Ç—Ä–∏–∫–∏ */
        .metric-description {
            background: rgba(52, 152, 219, 0.1);
            padding: 12px;
            border-radius: 8px;
            margin-bottom: 12px;
            font-size: 11px;
            line-height: 1.6;
        }
        
        .metric-description-title {
            font-weight: 700;
            color: #2c3e50;
            margin-bottom: 6px;
            font-size: 12px;
        }
        
        .metric-description-content {
            color: #34495e;
            margin-bottom: 8px;
        }
        
        .metric-description-formula {
            color: #7f8c8d;
            font-style: italic;
            font-size: 10px;
        }
        
    </style>
</head>
<body>
    <div id="container">
        <svg id="graph"></svg>
        
        <div id="modalOverlay"></div>
            <div id="detailModal">
                <button class="close-btn" onclick="closeDetailModal()">√ó</button>
                <div id="modalContent"></div>
            </div>
        
        <div id="legend">
            <h3>üîç –§–∏–ª—å—Ç—Ä—ã –∏ –ª–µ–≥–µ–Ω–¥–∞</h3>
            
            <div class="legend-section">
                <h4>
                    <span>–§–∏–ª–æ—Å–æ—Ñ—ã:</span>
                </h4>
                <div class="filter-controls">
                    <button onclick="selectAllPhilosophers()">–í—Å–µ</button>
                    <button onclick="deselectAllPhilosophers()">–°–±—Ä–æ—Å–∏—Ç—å</button>
                </div>
                <div id="philosopherFilters"></div>
            </div>
        
            <div class="legend-section">
                <h4>
                    <span>–†–µ–∂–∏–º —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏:</span>
                </h4>
                <div class="legend-item">
                    <input type="radio" id="filterAll" name="filterMode" value="all" checked onchange="changeFilterMode('all')">
                    <label for="filterAll" style="font-size: 11px;">
                        <span>–¢–æ–ª—å–∫–æ –≤—ã–±—Ä–∞–Ω–Ω—ã–µ —Ñ–∏–ª–æ—Å–æ—Ñ—ã</span>
                    </label>
                </div>
                <div class="legend-item">
                    <input type="radio" id="filterInternal" name="filterMode" value="internal" onchange="changeFilterMode('internal')">
                    <label for="filterInternal" style="font-size: 11px;">
                        <span>–¢–æ–ª—å–∫–æ –≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏–µ —Å–≤—è–∑–∏</span>
                    </label>
                </div>
                <div class="legend-item">
                    <input type="radio" id="filterContext" name="filterMode" value="context" onchange="changeFilterMode('context')">
                    <label for="filterContext" style="font-size: 11px;">
                        <span>–° —Å–æ—Å–µ–¥–Ω–∏–º–∏ —É–∑–ª–∞–º–∏</span>
                    </label>
                </div>
                <div style="font-size: 10px; color: #7f8c8d; margin-top: 8px; padding: 8px; background: rgba(108, 92, 231, 0.05); border-radius: 5px; line-height: 1.4;">
                    <strong>–†–µ–∂–∏–º—ã:</strong><br>
                    ‚Ä¢ <em>–¢–æ–ª—å–∫–æ –≤—ã–±—Ä–∞–Ω–Ω—ã–µ</em> - —É–∑–ª—ã –∏ —Å–≤—è–∑–∏ –º–µ–∂–¥—É –Ω–∏–º–∏<br>
                    ‚Ä¢ <em>–¢–æ–ª—å–∫–æ –≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏–µ</em> - —Å–≤—è–∑–∏ –≤–Ω—É—Ç—Ä–∏ —Å–∏—Å—Ç–µ–º<br>
                    ‚Ä¢ <em>–° —Å–æ—Å–µ–¥–Ω–∏–º–∏</em> - –≤–∫–ª—é—á–∞—è —Å–≤—è–∑–∞–Ω–Ω—ã–µ —É–∑–ª—ã –¥—Ä—É–≥–∏—Ö —Ñ–∏–ª–æ—Å–æ—Ñ–æ–≤
                </div>
            </div>
        
            <div class="legend-section">
                <h4>
                    <span>–¢–∏–ø—ã —Å–≤—è–∑–µ–π:</span>
                </h4>
                <div class="filter-controls">
                    <button onclick="selectAllRelations()">–í—Å–µ</button>
                    <button onclick="deselectAllRelations()">–°–±—Ä–æ—Å–∏—Ç—å</button>
                </div>
                <div id="relationFilters"></div>
                <div class="weight-legend">
                    <div class="weight-item">
                        <div class="weight-line weak"></div>
                        <span>–°–ª–∞–±–æ–µ –≤–ª–∏—è–Ω–∏–µ</span>
                    </div>
                    <div class="weight-item">
                        <div class="weight-line medium"></div>
                        <span>–°—Ä–µ–¥–Ω–µ–µ –≤–ª–∏—è–Ω–∏–µ</span>
                    </div>
                    <div class="weight-item">
                        <div class="weight-line strong"></div>
                        <span>–°–∏–ª—å–Ω–æ–µ –≤–ª–∏—è–Ω–∏–µ</span>
                    </div>
                </div>
            </div>
        
            <div class="filter-stats" id="filterStats">
                –ü–æ–∫–∞–∑–∞–Ω–æ: –≤—Å–µ –∫–æ–Ω—Ü–µ–ø—Ü–∏–∏ –∏ —Å–≤—è–∑–∏
            </div>
        </div>
        
        <!-- –ü–∞–Ω–µ–ª—å –ø–æ–∏—Å–∫–∞ –ø—É—Ç–∏ -->
        <div id="pathFinder">
            <h3>
                <span class="panel-title">üîç –ü—É—Ç—å –º–µ–∂–¥—É –∫–æ–Ω—Ü–µ–ø—Ü–∏—è–º–∏</span>
                <button class="collapse-btn" onclick="togglePanel('pathFinder')" title="–°–≤–µ—Ä–Ω—É—Ç—å/–†–∞–∑–≤–µ—Ä–Ω—É—Ç—å">
                    <span class="expand-icon">‚àí</span>
                </button>
            </h3>
            <div class="panel-content">
                <div class="path-select-group">
                    <label for="sourceSelect">–û—Ç –∫–æ–Ω—Ü–µ–ø—Ü–∏–∏:</label>
                    <select id="sourceSelect">
                        <option value="">–í—ã–±–µ—Ä–∏—Ç–µ –∫–æ–Ω—Ü–µ–ø—Ü–∏—é...</option>
                    </select>
                </div>
                <div class="path-select-group">
                    <label for="targetSelect">–ö –∫–æ–Ω—Ü–µ–ø—Ü–∏–∏:</label>
                    <select id="targetSelect">
                        <option value="">–í—ã–±–µ—Ä–∏—Ç–µ –∫–æ–Ω—Ü–µ–ø—Ü–∏—é...</option>
                    </select>
                </div>
                <button id="findPathBtn" onclick="findAndShowPath()">–ù–∞–π—Ç–∏ –ø—É—Ç—å</button>
                
                <div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid #dfe6e9;">
                    <div style="font-size: 11px; margin-bottom: 8px;">
                        <label style="display: flex; align-items: center; margin-bottom: 5px; cursor: pointer;">
                            <input type="checkbox" id="respectChronology" checked style="margin-right: 8px;">
                            <span>–£—á–∏—Ç—ã–≤–∞—Ç—å —Ö—Ä–æ–Ω–æ–ª–æ–≥–∏—é</span>
                        </label>
                        <label style="display: flex; align-items: center; cursor: pointer;">
                            <input type="checkbox" id="respectDirection" checked style="margin-right: 8px;">
                            <span>–£—á–∏—Ç—ã–≤–∞—Ç—å –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–Ω–æ—Å—Ç—å —Å–≤—è–∑–µ–π</span>
                        </label>
                    </div>
                </div>
                
                <div id="pathResult"></div>
            </div>
        </div>
        
        <!-- –ü–∞–Ω–µ–ª—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ —Å –∫–Ω–æ–ø–∫–∞–º–∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è -->
        <div id="statsPanel">
            <h3>
                <span class="panel-title">üìä –ê–Ω–∞–ª–∏–∑ –≥—Ä–∞—Ñ–∞</span>
                <button class="collapse-btn" onclick="togglePanel('statsPanel')" title="–°–≤–µ—Ä–Ω—É—Ç—å/–†–∞–∑–≤–µ—Ä–Ω—É—Ç—å">
                    <span class="expand-icon">‚àí</span>
                </button>
            </h3>
            <div class="panel-content">
                <!-- –ü–µ—Ä–µ–∫–ª—é—á–∞—Ç–µ–ª–∏ —Ä–µ–∂–∏–º–æ–≤ -->
                <div class="stats-section">
                    <label style="display: flex; align-items: center; cursor: pointer; font-size: 11px; margin-bottom: 8px;">
                        <input type="checkbox" id="useWeightsToggle" checked style="margin-right: 8px;" onchange="toggleWeightUsage()">
                        <span>–£—á–∏—Ç—ã–≤–∞—Ç—å –≤–µ—Å–∞ —Å–≤—è–∑–µ–π</span>
                    </label>
                    <label style="display: flex; align-items: center; cursor: pointer; font-size: 11px; margin-bottom: 10px;">
                        <input type="checkbox" id="respectDirectionToggle" checked style="margin-right: 8px;" onchange="toggleDirectionUsage()">
                        <span>–£—á–∏—Ç—ã–≤–∞—Ç—å –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–Ω–æ—Å—Ç—å —Å–≤—è–∑–µ–π</span>
                    </label>
                </div>
                
                <!-- –ö–Ω–æ–ø–∫–∏ –∑–∞–ø—É—Å–∫–∞ –∞–Ω–∞–ª–∏–∑–∞ -->
                <div class="stats-section">
                    <h4>–ó–∞–ø—É—Å–∫ –∞–Ω–∞–ª–∏–∑–∞:</h4>
                    <div style="display: flex; flex-direction: column; gap: 5px;">
                        <button onclick="runFullAnalysis()" style="width: 100%; background: #3498db; color: white; border: none; padding: 8px; border-radius: 6px; cursor: pointer; font-size: 11px; font-weight: 600;">
                            üöÄ –ü–æ–ª–Ω—ã–π –∞–Ω–∞–ª–∏–∑
                        </button>
                        <button onclick="runQuickAnalysis()" style="width: 100%; background: #27ae60; color: white; border: none; padding: 8px; border-radius: 6px; cursor: pointer; font-size: 11px; font-weight: 600;">
                            ‚ö° –ë—ã—Å—Ç—Ä—ã–π –∞–Ω–∞–ª–∏–∑
                        </button>
                        <button onclick="clearAllCache()" style="width: 100%; background: #95a5a6; color: white; border: none; padding: 8px; border-radius: 6px; cursor: pointer; font-size: 11px; font-weight: 600;">
                            üîÑ –°–±—Ä–æ—Å–∏—Ç—å –∫—ç—à
                        </button>
                    </div>
                </div>
                
                <!-- –û–±—â–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ -->
                <div class="stats-section" id="generalStatsSection" style="display: none;">
                    <h4>–û–±—â–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞</h4>
                    <div id="generalStats" style="font-size: 11px; line-height: 1.8;"></div>
                </div>
                
                <!-- –ö–Ω–æ–ø–∫–∞ –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏–∏ —Ä–∞–∑–º–µ—Ä–æ–º -->
                <div class="stats-section" id="visualizationSection" style="display: none;">
                    <button id="visualizeSizeBtn" onclick="toggleVisualizationBySize()" style="width: 100%; background: #27ae60; color: white; border: none; padding: 8px; border-radius: 6px; cursor: pointer; font-size: 11px; font-weight: 600; transition: background 0.3s;">
                        üìè –í–∏–∑—É–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å —Ä–∞–∑–º–µ—Ä–æ–º
                    </button>
                </div>
                
                <!-- –¢–∞–±—ã –¥–ª—è –º–µ—Ç—Ä–∏–∫ -->
                <div class="stats-section" id="metricsSection" style="display: none;">
                    <div class="metric-tabs" style="display: flex; gap: 3px; margin-bottom: 10px; flex-wrap: wrap;">
                        <button class="tab-btn" data-metric="degree" onclick="switchMetric('degree')" style="flex: 1; min-width: 70px; background: #ecf0f1; border: none; padding: 6px 4px; border-radius: 4px; cursor: pointer; font-size: 10px; font-weight: 600; transition: background 0.2s;">
                            Degree
                        </button>
                        <button class="tab-btn" data-metric="pagerank" onclick="switchMetric('pagerank')" style="flex: 1; min-width: 70px; background: #ecf0f1; border: none; padding: 6px 4px; border-radius: 4px; cursor: pointer; font-size: 10px; font-weight: 600; transition: background 0.2s;">
                            PageRank
                        </button>
                        <button class="tab-btn" data-metric="betweenness" onclick="switchMetric('betweenness')" style="flex: 1; min-width: 70px; background: #ecf0f1; border: none; padding: 6px 4px; border-radius: 4px; cursor: pointer; font-size: 10px; font-weight: 600; transition: background 0.2s;">
                            Between.
                        </button>
                        <button class="tab-btn" data-metric="closeness" onclick="switchMetric('closeness')" style="flex: 1; min-width: 70px; background: #ecf0f1; border: none; padding: 6px 4px; border-radius: 4px; cursor: pointer; font-size: 10px; font-weight: 600; transition: background 0.2s;">
                            Closeness
                        </button>
                        <button class="tab-btn" data-metric="clustering" onclick="switchMetric('clustering')" style="flex: 1; min-width: 70px; background: #ecf0f1; border: none; padding: 6px 4px; border-radius: 4px; cursor: pointer; font-size: 10px; font-weight: 600; transition: background 0.2s;">
                            Clustering
                        </button>
                        <button class="tab-btn" data-metric="eigenvector" onclick="switchMetric('eigenvector')" style="flex: 1; min-width: 70px; background: #ecf0f1; border: none; padding: 6px 4px; border-radius: 4px; cursor: pointer; font-size: 10px; font-weight: 600; transition: background 0.2s;">
                            Eigenvec.
                        </button>
                    </div>
                    <div id="metricContent"></div>
                </div>
                
                <!-- –ò–Ω–¥–∏–∫–∞—Ç–æ—Ä –ø—Ä–æ–≥—Ä–µ—Å—Å–∞ -->
                <div id="analysisProgress" style="display: none; margin-top: 15px; padding: 12px; background: rgba(52, 152, 219, 0.1); border-radius: 8px;">
                    <div style="font-size: 11px; color: #2d3436; margin-bottom: 8px;">
                        <strong id="progressLabel">–í—ã—á–∏—Å–ª–µ–Ω–∏–µ...</strong>
                    </div>
                    <div style="background: rgba(52, 152, 219, 0.2); height: 6px; border-radius: 3px; overflow: hidden;">
                        <div id="progressBar" style="background: #3498db; height: 100%; width: 0%; transition: width 0.3s;"></div>
                    </div>
                    <div style="font-size: 10px; color: #7f8c8d; margin-top: 5px;">
                        <span id="progressPercent">0%</span>
                    </div>
                </div>
            </div>
        </div>

        <div id="controls">
            <button onclick="resetSimulation()">üîÑ –ü–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏—Ç—å</button>
            <button onclick="centerGraph()">üéØ –¶–µ–Ω—Ç—Ä–∏—Ä–æ–≤–∞—Ç—å</button>
            <button id="groupBtn" onclick="toggleGrouping()">üì¶ –ì—Ä—É–ø–ø–∏—Ä–æ–≤–∞—Ç—å</button>
            <div id="exportButtons">
                <button onclick="exportToPNG()">üíæ PNG</button>
                <button onclick="exportToSVG()">üíæ SVG</button>
            </div>
        </div>

        <div id="info">
            üí° –ö–ª–∏–∫ - –ø–æ–¥—Å–≤–µ—Ç–∫–∞ ‚Ä¢ Ctrl+–∫–ª–∏–∫ - –º–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã–π –≤—ã–±–æ—Ä ‚Ä¢ –î–≤–æ–π–Ω–æ–π –∫–ª–∏–∫ - –¥–µ—Ç–∞–ª–∏ ‚Ä¢ –ü–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–π—Ç–µ ‚Ä¢ –ö–æ–ª–µ—Å–æ - –º–∞—Å—à—Ç–∞–±
        </div>

        <div class="tooltip" id="tooltip"></div>
    </div>

    <script>
        // ============================================
        // 1. –§–ò–õ–û–°–û–§–´ (–µ–¥–∏–Ω—ã–π –∏—Å—Ç–æ—á–Ω–∏–∫ –∏—Å—Ç–∏–Ω—ã)
        // ============================================
        const philosophers = [
            { id: "socrates", name: "–°–æ–∫—Ä–∞—Ç", nameRu: "–°–æ–∫—Ä–∞—Ç", color: "#e74c3c", birth: -469, death: -399, years: "469-399 –¥–æ –Ω.—ç." },
            { id: "plato", name: "–ü–ª–∞—Ç–æ–Ω", nameRu: "–ü–ª–∞—Ç–æ–Ω", color: "#c0392b", birth: -428, death: -348, years: "428-348 –¥–æ –Ω.—ç." },
            //...–∏ –¥–∞–ª–µ–µ
            { id: "russell", name: "–†–∞—Å—Å–µ–ª", nameRu: "–ë–µ—Ä—Ç—Ä–∞–Ω –†–∞—Å—Å–µ–ª", color: "#3498db", birth: 1872, death: 1970, years: "1872-1970" },
            { id: "heidegger", name: "–•–∞–π–¥–µ–≥–≥–µ—Ä", nameRu: "–•–∞–π–¥–µ–≥–≥–µ—Ä", color: "#e67e22", birth: 1889, death: 1976, years: "1889-1976" }
        ];
        
        // ============================================
        // 2. –†–£–ë–†–ò–ö–ò (—Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–∏–µ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏)
        // ============================================
        const rubrics = [
            {
                id: "being",
                name: "–ë—ã—Ç–∏–µ/–°—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–µ",
                description: "–§—É–Ω–¥–∞–º–µ–Ω—Ç–∞–ª—å–Ω—ã–µ –≤–æ–ø—Ä–æ—Å—ã –æ –ø—Ä–∏—Ä–æ–¥–µ —Ä–µ–∞–ª—å–Ω–æ—Å—Ç–∏ –∏ —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏—è"
            },
            //...–∏ –¥–∞–ª–µ–µ
            {
                id: "knowledge",
                name: "–ò—Å—Ç–∏–Ω–∞/–ü–æ–∑–Ω–∞–Ω–∏–µ",
                description: "–í–æ–ø—Ä–æ—Å—ã –ø–æ–∑–Ω–∞–Ω–∏—è, –∏—Å—Ç–∏–Ω—ã –∏ –µ—ë –∫—Ä–∏—Ç–µ—Ä–∏–µ–≤"
            },
            {
                id: "method",
                name: "–ú–µ—Ç–æ–¥",
                description: "–§–∏–ª–æ—Å–æ—Ñ—Å–∫–∏–µ –º–µ—Ç–æ–¥—ã –∏ –ø–æ–¥—Ö–æ–¥—ã"
            }
        ];
        
        // ============================================
        // 3. –¢–ò–ü–´ –°–í–Ø–ó–ï–ô
        // ============================================
        const relationTypes = [
            { id: "oppose", label: "–ø—Ä–æ—Ç–∏–≤–æ–ø–æ—Å—Ç–∞–≤–ª–µ–Ω–∏–µ", color: "#e74c3c" },
            { id: "ground", label: "–æ–±–æ—Å–Ω–æ–≤—ã–≤–∞–µ—Ç", color: "#3498db" },
            { id: "develop", label: "—Ä–∞–∑–≤–∏–≤–∞–µ—Ç", color: "#2ecc71" },
            { id: "critique", label: "–∫—Ä–∏—Ç–∏–∫—É–µ—Ç", color: "#f39c12" },
            { id: "synthesize", label: "—Å–∏–Ω—Ç–µ–∑–∏—Ä—É–µ—Ç", color: "#9b59b6" },
            { id: "influence", label: "–≤–ª–∏—è–µ—Ç", color: "#1abc9c" },
            { id: "dialogue", label: "–¥–∏–∞–ª–æ–≥", color: "#95a5a6" },
            { id: "internal_contradiction", label: "–≤–Ω—É—Ç—Ä–µ–Ω–Ω–µ–µ –ø—Ä–æ—Ç–∏–≤–æ—Ä–µ—á–∏–µ", color: "#e74c3c" },
            //...–∏ –¥–∞–ª–µ–µ
            { id: "limit", label: "–æ–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ—Ç", color: "#e67e22" }
        ];
        
        // ============================================
        // 4. –ö–û–ù–¶–ï–ü–¶–ò–ò
        // ============================================
        const concepts = [
            { 
                id: "maieutics", 
                label: "–ú–∞–π–µ–≤—Ç–∏–∫–∞", 
                philosopher: "socrates", 
                rubrics: ["knowledge", "method"], 
                description: "–ú–µ—Ç–æ–¥ –∏–∑–≤–ª–µ—á–µ–Ω–∏—è –∑–Ω–∞–Ω–∏—è —á–µ—Ä–µ–∑ –≤–æ–ø—Ä–æ—Å—ã",
                extendedDescription: "–ò—Å–∫—É—Å—Å—Ç–≤–æ —Ñ–∏–ª–æ—Å–æ—Ñ—Å–∫–æ–≥–æ –∞–∫—É—à–µ—Ä—Å—Ç–≤–∞, –ø—Ä–∏ –∫–æ—Ç–æ—Ä–æ–º –°–æ–∫—Ä–∞—Ç —á–µ—Ä–µ–∑ —Å–∏—Å—Ç–µ–º—É –Ω–∞–≤–æ–¥—è—â–∏—Ö –≤–æ–ø—Ä–æ—Å–æ–≤ –ø–æ–º–æ–≥–∞–ª —Å–æ–±–µ—Å–µ–¥–Ω–∏–∫—É '—Ä–æ–¥–∏—Ç—å' –∏—Å—Ç–∏–Ω—É –∏–∑ —Å–æ–±—Å—Ç–≤–µ–Ω–Ω–æ–≥–æ —Ä–∞–∑—É–º–∞. –û—Å–Ω–æ–≤–∞–Ω –Ω–∞ —É–±–µ–∂–¥–µ–Ω–∏–∏, —á—Ç–æ –∑–Ω–∞–Ω–∏–µ —É–∂–µ –ø—Ä–∏—Å—É—Ç—Å—Ç–≤—É–µ—Ç –≤ –¥—É—à–µ —á–µ–ª–æ–≤–µ–∫–∞ –∏ –Ω—É–∂–¥–∞–µ—Ç—Å—è –ª–∏—à—å –≤ –ø—Ä–∞–≤–∏–ª—å–Ω–æ–º —Å–ø–æ—Å–æ–±–µ –∏–∑–≤–ª–µ—á–µ–Ω–∏—è. –ú–µ—Ç–æ–¥ –ø—Ä–µ–¥–ø–æ–ª–∞–≥–∞–µ—Ç –ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ–µ –æ–ø—Ä–æ–≤–µ—Ä–∂–µ–Ω–∏–µ –ª–æ–∂–Ω—ã—Ö –º–Ω–µ–Ω–∏–π –∏ –ø–æ—Å—Ç–µ–ø–µ–Ω–Ω–æ–µ –ø—Ä–∏–±–ª–∏–∂–µ–Ω–∏–µ –∫ –∏—Å—Ç–∏–Ω–Ω–æ–º—É –∑–Ω–∞–Ω–∏—é —á–µ—Ä–µ–∑ –¥–∏–∞–ª–µ–∫—Ç–∏—á–µ—Å–∫–∏–π –ø—Ä–æ—Ü–µ—Å—Å."
            },
            { 
                id: "anamnesis", 
                label: "–ê–Ω–∞–º–Ω–µ—Å–∏—Å", 
                philosopher: "plato", 
                rubrics: ["knowledge"], 
                description: "–í–æ—Å–ø–æ–º–∏–Ω–∞–Ω–∏–µ –¥—É—à–∏ –æ–± –∏–¥–µ—è—Ö",
                extendedDescription: "–¢–µ–æ—Ä–∏—è –ø–æ–∑–Ω–∞–Ω–∏—è –∫–∞–∫ –ø—Ä–∏–ø–æ–º–∏–Ω–∞–Ω–∏—è —Ç–æ–≥–æ, —á—Ç–æ –¥—É—à–∞ —Å–æ–∑–µ—Ä—Ü–∞–ª–∞ –¥–æ –≤–æ–ø–ª–æ—â–µ–Ω–∏—è –≤ —Ç–µ–ª–µ. –î—É—à–∞, –ø—Ä–µ–±—ã–≤–∞—è –≤ –º–∏—Ä–µ –∏–¥–µ–π –¥–æ —Ä–æ–∂–¥–µ–Ω–∏—è, –æ–±–ª–∞–¥–∞–ª–∞ –ø–æ–ª–Ω—ã–º –∑–Ω–∞–Ω–∏–µ–º; –≤–æ–ø–ª–æ—â–µ–Ω–∏–µ –≤—ã–∑—ã–≤–∞–µ—Ç –∑–∞–±–≤–µ–Ω–∏–µ, –∞ –ø—Ä–æ—Ü–µ—Å—Å –æ–±—É—á–µ–Ω–∏—è –µ—Å—Ç—å –ø–æ—Å—Ç–µ–ø–µ–Ω–Ω–æ–µ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ —É—Ç—Ä–∞—á–µ–Ω–Ω–æ–≥–æ –∑–Ω–∞–Ω–∏—è. –ß—É–≤—Å—Ç–≤–µ–Ω–Ω—ã–π –æ–ø—ã—Ç —Å–ª—É–∂–∏—Ç –ª–∏—à—å –ø–æ–≤–æ–¥–æ–º –¥–ª—è –ø—Ä–æ–±—É–∂–¥–µ–Ω–∏—è –¥—Ä–µ–º–ª—é—â–∏—Ö –≤ –¥—É—à–µ –≤–æ—Å–ø–æ–º–∏–Ω–∞–Ω–∏–π –æ–± –∏–¥–µ–∞–ª—å–Ω—ã—Ö —Å—É—â–Ω–æ—Å—Ç—è—Ö."
            },
            //...–∏ –¥–∞–ª–µ–µ
            { 
                id: "external_world", 
                label: "–í–Ω–µ—à–Ω–∏–π –º–∏—Ä", 
                philosopher: "russell", 
                rubrics: ["being"], 
                description: "–ü—Ä–æ–±–ª–µ–º–∞ —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏—è –≤–Ω–µ—à–Ω–µ–≥–æ –º–∏—Ä–∞",
                extendedDescription: "–ü—Ä–æ–±–ª–µ–º–∞ –≤–Ω–µ—à–Ω–µ–≥–æ –º–∏—Ä–∞ –¥–ª—è –†–∞—Å—Å–µ–ª–∞: –∫–∞–∫ –Ω–∞ –æ—Å–Ω–æ–≤–∞–Ω–∏–∏ –∑–Ω–∞–Ω–∏—è —á—É–≤—Å—Ç–≤–µ–Ω–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö –æ–±–æ—Å–Ω–æ–≤–∞—Ç—å —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–µ –Ω–µ–∑–∞–≤–∏—Å–∏–º—ã—Ö –æ—Ç —Å–æ–∑–Ω–∞–Ω–∏—è —Ñ–∏–∑–∏—á–µ—Å–∫–∏—Ö –æ–±—ä–µ–∫—Ç–æ–≤? –†–∞—Å—Å–µ–ª –ø—Ä–µ–¥–ª–∞–≥–∞–µ—Ç –≥–∏–ø–æ—Ç–µ–∑—É, —á—Ç–æ —Ñ–∏–∑–∏—á–µ—Å–∫–∏–µ –æ–±—ä–µ–∫—Ç—ã - –ª–æ–≥–∏—á–µ—Å–∫–∏–µ –∫–æ–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏ –∏–∑ —á—É–≤—Å—Ç–≤–µ–Ω–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö –∏ –≤–æ–∑–º–æ–∂–Ω—ã—Ö —á—É–≤—Å—Ç–≤–µ–Ω–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö (sensibilia). –≠—Ç–æ –ø–æ–ø—ã—Ç–∫–∞ –ø—Ä–∏–º–∏—Ä–∏—Ç—å —ç–º–ø–∏—Ä–∏–∑–º —Å —Ä–µ–∞–ª–∏–∑–º–æ–º. –§–∏–∑–∏—á–µ—Å–∫–∏–µ –æ–±—ä–µ–∫—Ç—ã –Ω–µ –ø–æ–∑–Ω–∞—é—Ç—Å—è –Ω–∞–ø—Ä—è–º—É—é, –Ω–æ –ø–æ—Å—Ç—É–ª–∏—Ä—É—é—Ç—Å—è –∫–∞–∫ –Ω–∞–∏–ª—É—á—à–µ–µ –æ–±—ä—è—Å–Ω–µ–Ω–∏–µ —É–ø–æ—Ä—è–¥–æ—á–µ–Ω–Ω–æ—Å—Ç–∏ –æ–ø—ã—Ç–∞. –ü–æ–∑–¥–Ω–µ–µ –†–∞—Å—Å–µ–ª —Å–∫–ª–æ–Ω—è–µ—Ç—Å—è –∫ –±–æ–ª–µ–µ —Ä–µ–∞–ª–∏—Å—Ç–∏—á–µ—Å–∫–∏–º –ø–æ–∑–∏—Ü–∏—è–º, –ø—Ä–∏–∑–Ω–∞–≤–∞—è –Ω–µ–ø–æ—Å—Ä–µ–¥—Å—Ç–≤–µ–Ω–Ω–æ–µ –∑–Ω–∞–Ω–∏–µ —Ñ–∏–∑–∏—á–µ—Å–∫–∏—Ö –æ–±—ä–µ–∫—Ç–æ–≤."
            },
            { 
                id: "dasein", 
                label: "Dasein", 
                philosopher: "heidegger", 
                rubrics: ["being"], 
                description: "–ß–µ–ª–æ–≤–µ—á–µ—Å–∫–æ–µ –±—ã—Ç–∏–µ-–≤-–º–∏—Ä–µ",
                extendedDescription: "–ù–µ '—á–µ–ª–æ–≤–µ–∫' –∫–∞–∫ —Å—É–±—Å—Ç–∞–Ω—Ü–∏—è, –∞ —Å–ø–æ—Å–æ–± –±—ã—Ç—å, —ç–∫–∑–∏—Å—Ç–µ–Ω—Ü–∏—è - –ø—Ä–∏—Å—É—Ç—Å—Ç–≤–∏–µ (Da-sein), –¥–ª—è –∫–æ—Ç–æ—Ä–æ–≥–æ –≤ –µ–≥–æ –±—ã—Ç–∏–∏ —Ä–µ—á—å –∏–¥–µ—Ç –æ —Å–∞–º–æ–º —ç—Ç–æ–º –±—ã—Ç–∏–∏. Dasein –≤—Å–µ–≥–¥–∞ —É–∂–µ –≤–±—Ä–æ—à–µ–Ω–æ –≤ –º–∏—Ä, –æ–∑–∞–±–æ—á–µ–Ω–æ –≤–µ—â–∞–º–∏ –∏ –¥—Ä—É–≥–∏–º–∏. –ù–µ –∏–∑–æ–ª–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —Å—É–±—ä–µ–∫—Ç, –∞ –±—ã—Ç–∏–µ-–≤-–º–∏—Ä–µ –∫–∞–∫ —Ü–µ–ª–æ—Å—Ç–Ω–∞—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∞. Dasein –æ–Ω—Ç–æ–ª–æ–≥–∏—á–µ—Å–∫–∏ –æ—Ç–ª–∏—á–∞–µ—Ç—Å—è –æ—Ç —Å—É—â–µ–≥–æ —Ç–µ–º, —á—Ç–æ –ø–æ–Ω–∏–º–∞–µ—Ç –±—ã—Ç–∏–µ. –ê–Ω–∞–ª–∏—Ç–∏–∫–∞ Dasein - –ø—É—Ç—å –∫ –≤–æ–ø—Ä–æ—Å—É –æ —Å–º—ã—Å–ª–µ –±—ã—Ç–∏—è –≤–æ–æ–±—â–µ."
            }
        ];
        
        // ============================================
        // 5. –°–í–Ø–ó–ò –ú–ï–ñ–î–£ –ö–û–ù–¶–ï–ü–¶–ò–Ø–ú–ò
        // ============================================
        const relations = [
            { source: "maieutics", target: "anamnesis", type: "influence", weight: 2 },
            //...–∏ –¥–∞–ª–µ–µ
            { source: "external_world", target: "dasein", type: "dialogue", weight: 1, bidirectional: true }
            
        ];

        // –°–æ–∑–¥–∞—ë–º –∫–∞—Ä—Ç—É —Ñ–∏–ª–æ—Å–æ—Ñ–æ–≤ –ø–æ id -> –∏–º—è –Ω–∞ —Ä—É—Å—Å–∫–æ–º
        const philosopherIdToName = {};
        philosophers.forEach(p => {
            philosopherIdToName[p.id] = p.nameRu;
        });
        
        // –°–æ–∑–¥–∞—ë–º –æ–±—ä–µ–∫—Ç philosopherConcepts –¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏ —Å —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–º –∫–æ–¥–æ–º
        const philosopherConcepts = {};
        philosophers.forEach(p => {
            philosopherConcepts[p.nameRu] = {
                color: p.color,
                years: p.years
            };
        });
        
        // –°–æ–∑–¥–∞—ë–º –æ–±—ä–µ–∫—Ç philosopherOrder (—É–∂–µ –µ—Å—Ç—å –≤ —Å—Ç–∞—Ä–æ–º –∫–æ–¥–µ, –Ω–æ –º–æ–∂–Ω–æ —Ä–µ–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å)
        const philosopherOrder = {};
        philosophers.forEach(p => {
            philosopherOrder[p.nameRu] = p.birth;
        });
        
        // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º relationTypes –∏–∑ –º–∞—Å—Å–∏–≤–∞ –≤ –æ–±—ä–µ–∫—Ç
        const relationTypesObj = {};
        relationTypes.forEach(rt => {
            relationTypesObj[rt.id] = {
                color: rt.color,
                label: rt.label
            };
        });
        
        // –°–æ–∑–¥–∞—ë–º nodes –∏–∑ concepts
        const nodes = concepts.map(c => ({
            id: c.id,
            label: c.label,
            concept: philosopherIdToName[c.philosopher], // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º id –≤ –∏–º—è
            description: c.description,
            extendedDescription: c.extendedDescription
        }));
        
        // –°–æ–∑–¥–∞—ë–º links –∏–∑ relations
        const links = relations.map(r => ({
            source: r.source,
            target: r.target,
            type: r.type,
            weight: r.weight || 2, // –í–µ—Å –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é, –µ—Å–ª–∏ –Ω–µ —É–∫–∞–∑–∞–Ω
            bidirectional: r.bidirectional || false
        }));
        
        // –°–æ–∑–¥–∞—ë–º –æ–±—Ä–∞—Ç–Ω—ã–π –∏–Ω–¥–µ–∫—Å –∫–æ–Ω—Ü–µ–ø—Ü–∏—è -> —Ä—É–±—Ä–∏–∫–∏
        const conceptToRubrics = {};
        concepts.forEach(c => {
            conceptToRubrics[c.id] = c.rubrics || [];
        });
        
        // –°–æ–∑–¥–∞—ë–º –æ–±—ä–µ–∫—Ç rubrics –¥–ª—è —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏
        const rubricsObj = {};
        rubrics.forEach(r => {
            rubricsObj[r.name] = {
                concepts: concepts.filter(c => c.rubrics && c.rubrics.includes(r.id)).map(c => c.id),
                description: r.description
            };
        });
        
        // –ò–Ω–¥–∏–≤–∏–¥—É–∞–ª—å–Ω—ã–µ –≤–µ—Å–∞ –¥–ª—è —Å–≤—è–∑–µ–π (–ø—Ä–∏–º–µ—Ä—ã –∫–ª—é—á–µ–≤—ã—Ö —Å–≤—è–∑–µ–π)
        const specificWeights = {
            "maieutics-anamnesis": 2
            //...–∏ –¥–∞–ª–µ–µ
        };
        
        // –ù–∞–∑–Ω–∞—á–∞–µ–º –≤–µ—Å–∞ –∏–∑ relations, –µ—Å–ª–∏ –æ–Ω–∏ —É–∂–µ –µ—Å—Ç—å
        links.forEach(link => {
            const key = getLinkKey(link);
            const reverseKey = `${typeof link.target === 'string' ? link.target : link.target.id}-${typeof link.source === 'string' ? link.source : link.source.id}`;
            
            // –ï—Å–ª–∏ –≤–µ—Å —É–∂–µ –∑–∞–¥–∞–Ω –≤ relations, –∏—Å–ø–æ–ª—å–∑—É–µ–º –µ–≥–æ
            if (link.weight) {
                // –ù–∏—á–µ–≥–æ –Ω–µ –¥–µ–ª–∞–µ–º, –≤–µ—Å —É–∂–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω
            }
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–ø–µ—Ü–∏—Ñ–∏—á–µ—Å–∫–∏–π –≤–µ—Å
            else if (specificWeights[key]) {
                link.weight = specificWeights[key];
            } else if (specificWeights[reverseKey] && link.bidirectional) {
                link.weight = specificWeights[reverseKey];
            } else {
                // –í–µ—Å –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Ç–∏–ø–∞ —Å–≤—è–∑–∏
                switch(link.type) {
                    case "ground":
                    case "develop":
                    case "synthesize":
                        link.weight = 2;
                        break;
                    case "internal_contradiction":
                        link.weight = 2;
                        break;
                    case "influence":
                    case "dialogue":
                        link.weight = 1;
                        break;
                    case "oppose":
                    case "critique":
                        link.weight = 2;
                        break;
                    default:
                        link.weight = 2;
                }
            }
        });
        
        // –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –¥–ª—è –ø–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏—è —Ä–µ–∂–∏–º–æ–≤ —Ä–∞—Å—á—ë—Ç–∞
        let useWeightedPaths = true;
        let respectDirection = true;
        
        // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∫–ª—é—á–∞ —Å–≤—è–∑–∏
        function getLinkKey(link) {
            const source = typeof link.source === 'string' ? link.source : link.source.id;
            const target = typeof link.target === 'string' ? link.target : link.target.id;
            return `${source}-${target}`;
        }
        
        // –ù–∞–∑–Ω–∞—á–∞–µ–º –≤–µ—Å–∞
        links.forEach(link => {
            const key = getLinkKey(link);
            const reverseKey = `${typeof link.target === 'string' ? link.target : link.target.id}-${typeof link.source === 'string' ? link.source : link.source.id}`;
            
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–ø–µ—Ü–∏—Ñ–∏—á–µ—Å–∫–∏–π –≤–µ—Å
            if (specificWeights[key]) {
                link.weight = specificWeights[key];
            } else if (specificWeights[reverseKey] && link.bidirectional) {
                link.weight = specificWeights[reverseKey];
            } else {
                // –í–µ—Å –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Ç–∏–ø–∞ —Å–≤—è–∑–∏
                switch(link.type) {
                    case "ground":
                    case "develop":
                    case "synthesize":
                        link.weight = 2; // –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é —Å—Ä–µ–¥–Ω–µ–µ –¥–ª—è —ç—Ç–∏—Ö —Ç–∏–ø–æ–≤
                        break;
                    case "internal_contradiction":
                        link.weight = 2; // –ü—Ä–æ—Ç–∏–≤–æ—Ä–µ—á–∏—è –æ–±—ã—á–Ω–æ –≤–∞–∂–Ω—ã
                        break;
                    case "influence":
                    case "dialogue":
                        link.weight = 1; // –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é —Å–ª–∞–±–æ–µ –¥–ª—è –∫–æ—Å–≤–µ–Ω–Ω—ã—Ö –≤–ª–∏—è–Ω–∏–π
                        break;
                    case "oppose":
                    case "critique":
                        link.weight = 2; // –ö—Ä–∏—Ç–∏–∫–∞ –æ–±—ã—á–Ω–æ —Å—É—â–µ—Å—Ç–≤–µ–Ω–Ω–∞
                        break;
                    default:
                        link.weight = 2;
                }
            }
        });
        
        // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –ª–æ–≥–∏–∫–∞: —É—Å–∏–ª–∏–≤–∞–µ–º –≤–µ—Å–∞ –¥–ª—è —Å–≤—è–∑–µ–π –≤–Ω—É—Ç—Ä–∏ –æ–¥–Ω–æ–≥–æ —Ñ–∏–ª–æ—Å–æ—Ñ–∞
        links.forEach(link => {
            const sourceNode = nodes.find(n => n.id === (typeof link.source === 'string' ? link.source : link.source.id));
            const targetNode = nodes.find(n => n.id === (typeof link.target === 'string' ? link.target : link.target.id));
            
            // –ï—Å–ª–∏ —Å–≤—è–∑—å –≤–Ω—É—Ç—Ä–∏ —Å–∏—Å—Ç–µ–º—ã –æ–¥–Ω–æ–≥–æ —Ñ–∏–ª–æ—Å–æ—Ñ–∞ –∏ —ç—Ç–æ ground/synthesize
            if (sourceNode && targetNode && 
                sourceNode.concept === targetNode.concept && 
                (link.type === "ground" || link.type === "synthesize")) {
                // –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º –≤–µ—Å –Ω–∞ 1, –Ω–æ –Ω–µ –±–æ–ª—å—à–µ 3
                link.weight = Math.min(link.weight + 1, 3);
            }
        });
        
        // –°–æ—Å—Ç–æ—è–Ω–∏–µ —Ñ–∏–ª—å—Ç—Ä–æ–≤
        let selectedPhilosophers = new Set(Object.keys(philosopherConcepts));
        let selectedRelations = new Set(Object.keys(relationTypesObj));
        
        // –†–µ–∂–∏–º—ã —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏: 'all' - —Ç–æ–ª—å–∫–æ –≤—ã–±—Ä–∞–Ω–Ω—ã–µ, 'internal' - —Ç–æ–ª—å–∫–æ –≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏–µ, 'context' - —Å —Å–æ—Å–µ–¥–Ω–∏–º–∏
        let filterMode = 'all';
        
        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å–µ–ª–µ–∫—Ç–æ–≤ –¥–ª—è –ø–æ–∏—Å–∫–∞ –ø—É—Ç–∏
        function initPathFinder() {
            const sourceSelect = document.getElementById('sourceSelect');
            const targetSelect = document.getElementById('targetSelect');
            
            nodes.forEach(node => {
                const option1 = document.createElement('option');
                option1.value = node.id;
                option1.textContent = `${node.label} (${node.concept})`;
                sourceSelect.appendChild(option1);
                
                const option2 = document.createElement('option');
                option2.value = node.id;
                option2.textContent = `${node.label} (${node.concept})`;
                targetSelect.appendChild(option2);
            });
        }
        
        // –ü–æ–∏—Å–∫ –∫—Ä–∞—Ç—á–∞–π—à–µ–≥–æ –ø—É—Ç–∏ –º–µ–∂–¥—É –¥–≤—É–º—è –∫–æ–Ω—Ü–µ–ø—Ü–∏—è–º–∏ (BFS)
        function findShortestPath(sourceId, targetId, respectChronology = true, useDirection = null) {
            // –ò—Å–ø–æ–ª—å–∑—É–µ–º –≥–ª–æ–±–∞–ª—å–Ω—ã–π –ø–∞—Ä–∞–º–µ—Ç—Ä, –µ—Å–ª–∏ –Ω–µ –ø–µ—Ä–µ–¥–∞–Ω —è–≤–Ω–æ
            const shouldRespectDirection = useDirection !== null ? useDirection : respectDirection;
            
            if (useWeightedPaths) {
                return findShortestPathWeighted(sourceId, targetId, respectChronology, shouldRespectDirection);
            } else {
                return findShortestPathUnweighted(sourceId, targetId, respectChronology, shouldRespectDirection);
            }
        }
        
        // –í–∑–≤–µ—à–µ–Ω–Ω—ã–π –ø–æ–∏—Å–∫ (–î–µ–π–∫—Å—Ç—Ä–∞)
        function findShortestPathWeighted(sourceId, targetId, respectChronology = true, shouldRespectDirection = true) {
            if (sourceId === targetId) return [sourceId];
            
            const distances = {};
            const previous = {};
            const unvisited = new Set();
            
            nodes.forEach(n => {
                distances[n.id] = Infinity;
                previous[n.id] = null;
                unvisited.add(n.id);
            });
            
            distances[sourceId] = 0;
            
            while (unvisited.size > 0) {
                // –ù–∞–π—Ç–∏ —É–∑–µ–ª —Å –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–º —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ–º
                let current = null;
                let minDist = Infinity;
                unvisited.forEach(nodeId => {
                    if (distances[nodeId] < minDist) {
                        minDist = distances[nodeId];
                        current = nodeId;
                    }
                });
                
                if (current === null || distances[current] === Infinity) break;
                if (current === targetId) break;
                
                unvisited.delete(current);
                
                const currentNode = nodes.find(n => n.id === current);
                
                // –û–±–Ω–æ–≤–∏—Ç—å —Ä–∞—Å—Å—Ç–æ—è–Ω–∏—è –¥–æ —Å–æ—Å–µ–¥–µ–π
                links.forEach(link => {
                    const src = link.source.id || link.source;
                    const tgt = link.target.id || link.target;
                    
                    let neighbor = null;
                    let canTraverse = false;
                    
                    if (shouldRespectDirection) {
                        // –£—á–∏—Ç—ã–≤–∞–µ–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–Ω–æ—Å—Ç—å
                        if (src === current) {
                            neighbor = tgt;
                            canTraverse = true;
                        } else if (link.bidirectional && tgt === current) {
                            neighbor = src;
                            canTraverse = true;
                        }
                    } else {
                        // –ù–µ —É—á–∏—Ç—ã–≤–∞–µ–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–Ω–æ—Å—Ç—å - –≥—Ä–∞—Ñ –Ω–µ–Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–π
                        if (src === current) {
                            neighbor = tgt;
                            canTraverse = true;
                        } else if (tgt === current) {
                            neighbor = src;
                            canTraverse = true;
                        }
                    }
                    
                    if (canTraverse && neighbor && unvisited.has(neighbor)) {
                        // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –≤–µ—Å: –±–æ–ª—å—à–∏–π –≤–µ—Å = –º–µ–Ω—å—à–∞—è "—Å—Ç–æ–∏–º–æ—Å—Ç—å" —Å–≤—è–∑–∏
                        const weight = link.weight || 2;
                        const cost = 4 - weight;
                        const alt = distances[current] + cost;
                        
                        if (respectChronology) {
                            const nextNode = nodes.find(n => n.id === neighbor);
                            const currentYear = philosopherOrder[currentNode.concept];
                            const nextYear = philosopherOrder[nextNode.concept];
                            
                            if (nextYear < currentYear - 50) return;
                        }
                        
                        if (alt < distances[neighbor]) {
                            distances[neighbor] = alt;
                            previous[neighbor] = current;
                        }
                    }
                });
            }
            
            // –í–æ—Å—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –ø—É—Ç—å
            if (distances[targetId] === Infinity) return null;
            
            const path = [];
            let current = targetId;
            while (current !== null) {
                path.unshift(current);
                current = previous[current];
            }
            
            return path;
        }
        
        // –ù–µ–≤–∑–≤–µ—à–µ–Ω–Ω—ã–π –ø–æ–∏—Å–∫ (BFS)
        function findShortestPathUnweighted(sourceId, targetId, respectChronology = true, shouldRespectDirection = true) {
            if (sourceId === targetId) return [sourceId];
            
            const queue = [[sourceId]];
            const visited = new Set([sourceId]);
            
            const adjacency = {};
            nodes.forEach(n => adjacency[n.id] = []);
            
            links.forEach(l => {
                const src = l.source.id || l.source;
                const tgt = l.target.id || l.target;
                
                if (shouldRespectDirection) {
                    adjacency[src].push(tgt);
                    if (l.bidirectional) {
                        adjacency[tgt].push(src);
                    }
                } else {
                    adjacency[src].push(tgt);
                    adjacency[tgt].push(src);
                }
            });
            
            while (queue.length > 0) {
                const path = queue.shift();
                const currentNodeId = path[path.length - 1];
                
                if (currentNodeId === targetId) {
                    return path;
                }
                
                const neighbors = adjacency[currentNodeId] || [];
                for (const neighborId of neighbors) {
                    if (!visited.has(neighborId)) {
                        if (respectChronology) {
                            const currentNode = nodes.find(n => n.id === currentNodeId);
                            const nextNode = nodes.find(n => n.id === neighborId);
                            
                            const currentYear = philosopherOrder[currentNode.concept];
                            const nextYear = philosopherOrder[nextNode.concept];
                            
                            if (nextYear < currentYear - 50) {
                                continue;
                            }
                        }
                        
                        visited.add(neighborId);
                        queue.push([...path, neighborId]);
                    }
                }
            }
            
            return null;
        }
        
        // –§—É–Ω–∫—Ü–∏—è –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –Ω–∞–π–¥–µ–Ω–Ω–æ–≥–æ –ø—É—Ç–∏
        function findAndShowPath() {
            const sourceId = document.getElementById('sourceSelect').value;
            const targetId = document.getElementById('targetSelect').value;
            const resultDiv = document.getElementById('pathResult');
            
            const respectChronology = document.getElementById('respectChronology').checked;
            const respectDirection = document.getElementById('respectDirection').checked;
            
            if (!sourceId || !targetId) {
                alert('–í—ã–±–µ—Ä–∏—Ç–µ –æ–±–µ –∫–æ–Ω—Ü–µ–ø—Ü–∏–∏');
                return;
            }
            
            if (sourceId === targetId) {
                alert('–í—ã–±–µ—Ä–∏—Ç–µ —Ä–∞–∑–Ω—ã–µ –∫–æ–Ω—Ü–µ–ø—Ü–∏–∏');
                return;
            }
            
            const path = findShortestPath(sourceId, targetId, respectChronology, respectDirection);
            
            if (!path) {
                const sourceNode = nodes.find(n => n.id === sourceId);
                const targetNode = nodes.find(n => n.id === targetId);
                
                let message = '–≠—Ç–∏ –∫–æ–Ω—Ü–µ–ø—Ü–∏–∏ –Ω–µ —Å–≤—è–∑–∞–Ω—ã';
                if (respectChronology && respectDirection) {
                    message += ' —Ö—Ä–æ–Ω–æ–ª–æ–≥–∏—á–µ—Å–∫–∏ –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–º –ø—É—Ç—ë–º —Å —É—á—ë—Ç–æ–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–Ω–æ—Å—Ç–∏ —Å–≤—è–∑–µ–π.';
                } else if (respectChronology) {
                    message += ' —Ö—Ä–æ–Ω–æ–ª–æ–≥–∏—á–µ—Å–∫–∏ –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–º –ø—É—Ç—ë–º.';
                } else if (respectDirection) {
                    message += ' —Å —É—á—ë—Ç–æ–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–Ω–æ—Å—Ç–∏ —Å–≤—è–∑–µ–π.';
                } else {
                    message += ' –≤ –≥—Ä–∞—Ñ–µ.';
                }
                
                resultDiv.innerHTML = `
                    <div class="path-length">‚ùå –ü—É—Ç—å –Ω–µ –Ω–∞–π–¥–µ–Ω</div>
                    <div class="path-chain">${message}<br><br>
                    <small style="color: #95a5a6;">–ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω—è—Ç—å –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è –Ω–∏–∂–µ.</small></div>
                    <button onclick="clearPathHighlight()" style="width: 100%; margin-top: 10px; background: #95a5a6; color: white; border: none; padding: 8px; border-radius: 6px; cursor: pointer; font-size: 12px;">
                        –û—á–∏—Å—Ç–∏—Ç—å
                    </button>
                `;
                resultDiv.classList.add('show');
                resetHighlight();
                return;
            }
            
            // –§–æ—Ä–º–∏—Ä—É–µ–º –≤–∏–∑—É–∞–ª—å–Ω–æ–µ –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏–µ –ø—É—Ç–∏
            const pathNodes = path.map(id => nodes.find(n => n.id === id));
            
            // –°–æ–∑–¥–∞—ë–º HTML —Å —É–∑–ª–∞–º–∏ –∏ —Å—Ç—Ä–µ–ª–∫–∞–º–∏
            let pathHTML = '';
            
            for (let i = 0; i < pathNodes.length; i++) {
                const node = pathNodes[i];
                const philosopherColor = philosopherConcepts[node.concept].color;
                
                // –î–æ–±–∞–≤–ª—è–µ–º —É–∑–µ–ª —Å —Ñ–∏–ª–æ—Å–æ—Ñ–æ–º
                pathHTML += `
                    <span class="path-node-container">
                        <span class="path-philosopher">${node.concept}</span>
                        <span class="path-node" style="border-color: ${philosopherColor};" title="${node.concept}: ${node.description}">
                            ${node.label}
                        </span>
                    </span>
                `;
                
                // –î–æ–±–∞–≤–ª—è–µ–º —Å—Ç—Ä–µ–ª–∫—É, –µ—Å–ª–∏ —ç—Ç–æ –Ω–µ –ø–æ—Å–ª–µ–¥–Ω–∏–π —É–∑–µ–ª
                if (i < pathNodes.length - 1) {
                    const currentNode = pathNodes[i];
                    const nextNode = pathNodes[i + 1];
                    
                    // –ù–∞—Ö–æ–¥–∏–º —Å–≤—è–∑—å –º–µ–∂–¥—É —Ç–µ–∫—É—â–∏–º –∏ —Å–ª–µ–¥—É—é—â–∏–º —É–∑–ª–æ–º
                    const link = links.find(l => {
                        const src = l.source.id || l.source;
                        const tgt = l.target.id || l.target;
                        
                        if (respectDirection) {
                            return (src === currentNode.id && tgt === nextNode.id) ||
                                   (l.bidirectional && src === nextNode.id && tgt === currentNode.id);
                        } else {
                            return (src === currentNode.id && tgt === nextNode.id) ||
                                   (src === nextNode.id && tgt === currentNode.id);
                        }
                    });
                    
                    if (link) {
                        const linkColor = relationTypesObj[link.type].color;
                        const linkLabel = relationTypesObj[link.type].label;
                        const src = link.source.id || link.source;
                        const tgt = link.target.id || link.target;
                        
                        // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Å—Ç—Ä–µ–ª–∫–∏
                        let arrow;
                        if (link.bidirectional) {
                            arrow = '‚Üî';
                        } else if (src === currentNode.id && tgt === nextNode.id) {
                            arrow = '‚Üí';
                        } else {
                            arrow = '‚Üê';
                        }
                        
                        pathHTML += `
                            <span class="path-arrow ${link.bidirectional ? 'bidirectional' : ''}" 
                                  style="color: ${linkColor};" 
                                  title="${linkLabel}">
                                ${arrow}
                            </span>
                        `;
                    } else {
                        // –ï—Å–ª–∏ —Å–≤—è–∑—å –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ (–Ω–µ –¥–æ–ª–∂–Ω–æ –ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç—å)
                        pathHTML += `<span class="path-arrow" style="color: #95a5a6;">‚Üí</span>`;
                    }
                }
            }
            
            // –î–æ–±–∞–≤–ª—è–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Ö—Ä–æ–Ω–æ–ª–æ–≥–∏–∏
            const years = pathNodes.map(n => philosopherConcepts[n.concept].years);
            const chronologyInfo = respectChronology ? 
                `<div style="margin-top: 8px; font-size: 10px; color: #7f8c8d;">
                    –•—Ä–æ–Ω–æ–ª–æ–≥–∏—è: ${years[0]} ‚Üí ${years[years.length - 1]}
                </div>` : '';
            
            resultDiv.innerHTML = `
                <div class="path-length">‚úÖ –î–ª–∏–Ω–∞ –ø—É—Ç–∏: ${path.length} –∫–æ–Ω—Ü–µ–ø—Ü–∏–π</div>
                <div class="path-chain" style="line-height: 2;">${pathHTML}</div>
                ${chronologyInfo}
                <button onclick="clearPathHighlight()" style="width: 100%; margin-top: 10px; background: #e74c3c; color: white; border: none; padding: 8px; border-radius: 6px; cursor: pointer; font-size: 12px; transition: background 0.3s;" onmouseover="this.style.background='#c0392b'" onmouseout="this.style.background='#e74c3c'">
                    üîÑ –°–±—Ä–æ—Å–∏—Ç—å –ø–æ–¥—Å–≤–µ—Ç–∫—É
                </button>
            `;
            resultDiv.classList.add('show');
            
            // –ü–æ–¥—Å–≤–µ—á–∏–≤–∞–µ–º –ø—É—Ç—å –Ω–∞ –≥—Ä–∞—Ñ–µ
            highlightPath(path, respectDirection);
        }
        
        // –ü–æ–¥—Å–≤–µ—Ç–∫–∞ –ø—É—Ç–∏ –Ω–∞ –≥—Ä–∞—Ñ–µ
        function highlightPath(path, respectDirection = true) {
            resetHighlight();
            
            const pathSet = new Set(path);
            const pathLinks = new Set();
            
            // –ù–∞—Ö–æ–¥–∏–º —Å–≤—è–∑–∏, –∫–æ—Ç–æ—Ä—ã–µ –≤—Ö–æ–¥—è—Ç –≤ –ø—É—Ç—å
            for (let i = 0; i < path.length - 1; i++) {
                const currentNode = path[i];
                const nextNode = path[i + 1];
                
                const link = links.find(l => {
                    const src = l.source.id || l.source;
                    const tgt = l.target.id || l.target;
                    
                    if (respectDirection) {
                        // –£—á–∏—Ç—ã–≤–∞–µ–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–Ω–æ—Å—Ç—å: –∏—â–µ–º —Å–≤—è–∑—å –≤ –ø—Ä—è–º–æ–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–∏ –∏–ª–∏ bidirectional
                        return (src === currentNode && tgt === nextNode) ||
                               (l.bidirectional && src === nextNode && tgt === currentNode);
                    } else {
                        // –ù–µ —É—á–∏—Ç—ã–≤–∞–µ–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–Ω–æ—Å—Ç—å: –ª—é–±–∞—è —Å–≤—è–∑—å –º–µ–∂–¥—É —ç—Ç–∏–º–∏ —É–∑–ª–∞–º–∏ –ø–æ–¥—Ö–æ–¥–∏—Ç
                        return (src === currentNode && tgt === nextNode) ||
                               (src === nextNode && tgt === currentNode);
                    }
                });
                
                if (link) pathLinks.add(link);
            }
            
            // –ü—Ä–∏–º–µ–Ω—è–µ–º —Å—Ç–∏–ª–∏
            node.classed("dimmed", d => !pathSet.has(d.id))
                .classed("highlighted", d => pathSet.has(d.id));
            
            link.classed("dimmed", l => !pathLinks.has(l))
                .classed("path-highlight", l => pathLinks.has(l));
        }
        
        // –û—á–∏—Å—Ç–∫–∞ –ø–æ–¥—Å–≤–µ—Ç–∫–∏ –ø—É—Ç–∏
        function clearPathHighlight() {
            resetHighlight();
            const resultDiv = document.getElementById('pathResult');
            resultDiv.classList.remove('show');
            resultDiv.innerHTML = '';
        }
        
        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Ñ–∏–ª—å—Ç—Ä–æ–≤
        function initFilters() {
            // –°–æ–∑–¥–∞–µ–º —Ñ–∏–ª—å—Ç—Ä—ã —Ñ–∏–ª–æ—Å–æ—Ñ–æ–≤
            const philContainer = document.getElementById('philosopherFilters');
            Object.entries(philosopherConcepts).forEach(([name, data]) => {
                const item = document.createElement('div');
                item.className = 'legend-item';
                item.innerHTML = `
                    <input type="checkbox" id="phil-${name}" checked onchange="togglePhilosopher('${name}')">
                    <label for="phil-${name}">
                        <div class="legend-color" style="background: ${data.color}"></div>
                        <span>${name}<small style="color: #95a5a6; font-size: 9px;"> (${data.years})</small></span>
                    </label>
                `;
                philContainer.appendChild(item);
            });
        
            // –°–æ–∑–¥–∞–µ–º —Ñ–∏–ª—å—Ç—Ä—ã —Å–≤—è–∑–µ–π (–±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π)
            const relContainer = document.getElementById('relationFilters');
            Object.entries(relationTypesObj).forEach(([type, typeData]) => {
                const item = document.createElement('div');
                item.className = 'legend-item';
                item.innerHTML = `
                    <input type="checkbox" id="rel-${type}" checked onchange="toggleRelation('${type}')">
                    <label for="rel-${type}">
                        <div class="legend-line" style="background: ${typeData.color}"></div>
                        <span>${typeData.label}</span>
                    </label>
                `;
                relContainer.appendChild(item);
            });
        }
        
        // –ü–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ —Ñ–∏–ª–æ—Å–æ—Ñ–∞
        function togglePhilosopher(philosopher) {
            if (selectedPhilosophers.has(philosopher)) {
                selectedPhilosophers.delete(philosopher);
            } else {
                selectedPhilosophers.add(philosopher);
            }
            applyFilters();
        }
        
        // –ü–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ —Ç–∏–ø–∞ —Å–≤—è–∑–∏
        function toggleRelation(relationType) {
            if (selectedRelations.has(relationType)) {
                selectedRelations.delete(relationType);
            } else {
                selectedRelations.add(relationType);
            }
            applyFilters();
        }
        
        // –í—ã–±—Ä–∞—Ç—å –≤—Å–µ—Ö —Ñ–∏–ª–æ—Å–æ—Ñ–æ–≤
        function selectAllPhilosophers() {
            selectedPhilosophers = new Set(Object.keys(philosopherConcepts));
            Object.keys(philosopherConcepts).forEach(name => {
                document.getElementById(`phil-${name}`).checked = true;
            });
            applyFilters();
        }
        
        // –°–Ω—è—Ç—å –≤—Å–µ—Ö —Ñ–∏–ª–æ—Å–æ—Ñ–æ–≤
        function deselectAllPhilosophers() {
            selectedPhilosophers.clear();
            Object.keys(philosopherConcepts).forEach(name => {
                document.getElementById(`phil-${name}`).checked = false;
            });
            applyFilters();
        }
        
        // –í—ã–±—Ä–∞—Ç—å –≤—Å–µ —Å–≤—è–∑–∏
        function selectAllRelations() {
            selectedRelations = new Set(Object.keys(relationTypesObj));
            Object.keys(relationTypesObj).forEach(type => {
                document.getElementById(`rel-${type}`).checked = true;
            });
            applyFilters();
        }
        
        // –°–Ω—è—Ç—å –≤—Å–µ —Å–≤—è–∑–∏
        function deselectAllRelations() {
            selectedRelations.clear();
            Object.keys(relationTypesObj).forEach(type => {
                document.getElementById(`rel-${type}`).checked = false;
            });
            applyFilters();
        }
        
        // –ü–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ —Ä–µ–∂–∏–º–∞ —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏
        function changeFilterMode(mode) {
            filterMode = mode;
            applyFilters();
        }
        
        // Debounce –¥–ª—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏ —á–∞—Å—Ç—ã—Ö –≤—ã–∑–æ–≤–æ–≤
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }
        
        // –û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è applyFilters —Å debounce
        const debouncedApplyFilters = debounce(function() {
            applyFiltersImmediate();
        }, 150);
        
        function applyFilters() {
            debouncedApplyFilters();
        }

        // –ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ —Ñ–∏–ª—å—Ç—Ä–æ–≤ —Å –≤–∑–∞–∏–º–æ—Å–≤—è–∑–∞–Ω–Ω–æ–π –ª–æ–≥–∏–∫–æ–π
        function applyFiltersImmediate() {
            const allRelationsSelected = selectedRelations.size === Object.keys(relationTypesObj).length;
            
            if (filterMode === 'all') {
                // –†–µ–∂–∏–º 1: –¢–æ–ª—å–∫–æ –≤—ã–±—Ä–∞–Ω–Ω—ã–µ —Ñ–∏–ª–æ—Å–æ—Ñ—ã
                // –°–≤—è–∑–∏, –≥–¥–µ –û–ë–ê —É–∑–ª–∞ –ø—Ä–∏–Ω–∞–¥–ª–µ–∂–∞—Ç –≤—ã–±—Ä–∞–Ω–Ω—ã–º —Ñ–∏–ª–æ—Å–æ—Ñ–∞–º
                const validLinks = links.filter(l => {
                    const typeSelected = selectedRelations.has(l.type);
                    const sourcePhilosopherSelected = selectedPhilosophers.has(l.source.concept);
                    const targetPhilosopherSelected = selectedPhilosophers.has(l.target.concept);
                    return typeSelected && sourcePhilosopherSelected && targetPhilosopherSelected;
                });
                
                const nodesInValidLinks = new Set();
                validLinks.forEach(l => {
                    nodesInValidLinks.add(l.source.id || l.source);
                    nodesInValidLinks.add(l.target.id || l.target);
                });
                
                node.style("display", d => {
                    const philosopherSelected = selectedPhilosophers.has(d.concept);
                    const inValidLinks = allRelationsSelected || nodesInValidLinks.has(d.id);
                    return (philosopherSelected && inValidLinks) ? null : "none";
                });
                
                link.style("display", l => {
                    const typeSelected = selectedRelations.has(l.type);
                    const sourcePhilosopherSelected = selectedPhilosophers.has(l.source.concept);
                    const targetPhilosopherSelected = selectedPhilosophers.has(l.target.concept);
                    const sourceInValidLinks = allRelationsSelected || nodesInValidLinks.has(l.source.id);
                    const targetInValidLinks = allRelationsSelected || nodesInValidLinks.has(l.target.id);
                    
                    return (typeSelected && sourcePhilosopherSelected && targetPhilosopherSelected && 
                            sourceInValidLinks && targetInValidLinks) ? null : "none";
                });
                
            } else if (filterMode === 'internal') {
                // –†–µ–∂–∏–º 2: –¢–æ–ª—å–∫–æ –≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏–µ —Å–≤—è–∑–∏
                // –°–≤—è–∑–∏, –≥–¥–µ –æ–±–∞ —É–∑–ª–∞ –æ—Ç –û–î–ù–û–ì–û —Ñ–∏–ª–æ—Å–æ—Ñ–∞ –∏–∑ –≤—ã–±—Ä–∞–Ω–Ω—ã—Ö
                const validLinks = links.filter(l => {
                    const typeSelected = selectedRelations.has(l.type);
                    const sourcePhilosopherSelected = selectedPhilosophers.has(l.source.concept);
                    const targetPhilosopherSelected = selectedPhilosophers.has(l.target.concept);
                    const samePhilosopher = l.source.concept === l.target.concept;
                    return typeSelected && sourcePhilosopherSelected && targetPhilosopherSelected && samePhilosopher;
                });
                
                const nodesInValidLinks = new Set();
                validLinks.forEach(l => {
                    nodesInValidLinks.add(l.source.id || l.source);
                    nodesInValidLinks.add(l.target.id || l.target);
                });
                
                node.style("display", d => {
                    const philosopherSelected = selectedPhilosophers.has(d.concept);
                    const inValidLinks = allRelationsSelected || nodesInValidLinks.has(d.id);
                    return (philosopherSelected && inValidLinks) ? null : "none";
                });
                
                link.style("display", l => {
                    const typeSelected = selectedRelations.has(l.type);
                    const sourcePhilosopherSelected = selectedPhilosophers.has(l.source.concept);
                    const targetPhilosopherSelected = selectedPhilosophers.has(l.target.concept);
                    const samePhilosopher = l.source.concept === l.target.concept;
                    const sourceInValidLinks = allRelationsSelected || nodesInValidLinks.has(l.source.id);
                    const targetInValidLinks = allRelationsSelected || nodesInValidLinks.has(l.target.id);
                    
                    return (typeSelected && sourcePhilosopherSelected && targetPhilosopherSelected && 
                            samePhilosopher && sourceInValidLinks && targetInValidLinks) ? null : "none";
                });
                
            } else if (filterMode === 'context') {
                // –†–µ–∂–∏–º 3: –° —Å–æ—Å–µ–¥–Ω–∏–º–∏ —É–∑–ª–∞–º–∏
                // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –≤—ã–±—Ä–∞–Ω–Ω—ã—Ö —Ñ–∏–ª–æ—Å–æ—Ñ–æ–≤ + –≤—Å–µ —É–∑–ª—ã, —Å –∫–æ—Ç–æ—Ä—ã–º–∏ –æ–Ω–∏ —Å–≤—è–∑–∞–Ω—ã
                
                // –°–Ω–∞—á–∞–ª–∞ –Ω–∞—Ö–æ–¥–∏–º –≤—Å–µ —Å–≤—è–∑–∏, –≥–¥–µ —Ö–æ—Ç—è –±—ã –û–î–ò–ù –∫–æ–Ω–µ—Ü - –≤—ã–±—Ä–∞–Ω–Ω—ã–π —Ñ–∏–ª–æ—Å–æ—Ñ
                const validLinks = links.filter(l => {
                    const typeSelected = selectedRelations.has(l.type);
                    const sourcePhilosopherSelected = selectedPhilosophers.has(l.source.concept);
                    const targetPhilosopherSelected = selectedPhilosophers.has(l.target.concept);
                    // –°–≤—è–∑—å –≤–∞–ª–∏–¥–Ω–∞, –µ—Å–ª–∏ —Ö–æ—Ç—è –±—ã –æ–¥–∏–Ω –∫–æ–Ω–µ—Ü –ø—Ä–∏–Ω–∞–¥–ª–µ–∂–∏—Ç –≤—ã–±—Ä–∞–Ω–Ω–æ–º—É —Ñ–∏–ª–æ—Å–æ—Ñ—É
                    return typeSelected && (sourcePhilosopherSelected || targetPhilosopherSelected);
                });
                
                // –°–æ–±–∏—Ä–∞–µ–º –≤—Å–µ —É–∑–ª—ã, —É—á–∞—Å—Ç–≤—É—é—â–∏–µ –≤ —ç—Ç–∏—Ö —Å–≤—è–∑—è—Ö (–≤–∫–ª—é—á–∞—è "—Å–æ—Å–µ–¥–µ–π")
                const visibleNodes = new Set();
                validLinks.forEach(l => {
                    visibleNodes.add(l.source.id || l.source);
                    visibleNodes.add(l.target.id || l.target);
                });
                
                // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –≤—Å–µ —É–∑–ª—ã, –∫–æ—Ç–æ—Ä—ã–µ —É—á–∞—Å—Ç–≤—É—é—Ç –≤ –≤–∞–ª–∏–¥–Ω—ã—Ö —Å–≤—è–∑—è—Ö
                node.style("display", d => {
                    return visibleNodes.has(d.id) ? null : "none";
                });
                
                // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –≤—Å–µ –≤–∞–ª–∏–¥–Ω—ã–µ —Å–≤—è–∑–∏
                link.style("display", l => {
                    const typeSelected = selectedRelations.has(l.type);
                    const sourcePhilosopherSelected = selectedPhilosophers.has(l.source.concept);
                    const targetPhilosopherSelected = selectedPhilosophers.has(l.target.concept);
                    const sourceVisible = visibleNodes.has(l.source.id);
                    const targetVisible = visibleNodes.has(l.target.id);
                    
                    return (typeSelected && (sourcePhilosopherSelected || targetPhilosopherSelected) && 
                            sourceVisible && targetVisible) ? null : "none";
                });
            }
            
            // –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
            updateFilterStats();
            
            // –°–±—Ä–∞—Å—ã–≤–∞–µ–º –ø–æ–¥—Å–≤–µ—Ç–∫—É –¥–ª—è —Å–∫—Ä—ã—Ç—ã—Ö —É–∑–ª–æ–≤
            const visibleNodeIds = new Set();
            node.each(function(d) {
                if (this.style.display !== "none") {
                    visibleNodeIds.add(d.id);
                }
            });
            
            selectedNodes.forEach(node => {
                if (!visibleNodeIds.has(node.id)) {
                    selectedNodes.delete(node);
                }
            });
        
            if (selectedNodes.size === 0) {
                resetHighlight();
            } else {
                highlightConnected(Array.from(selectedNodes));
            }
        }
        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ —Ñ–∏–ª—å—Ç—Ä–æ–≤
        function updateFilterStats() {
            let visibleNodesCount = 0;
            let visibleLinksCount = 0;
            
            node.each(function() {
                if (this.style.display !== "none") visibleNodesCount++;
            });
            
            link.each(function() {
                if (this.style.display !== "none") visibleLinksCount++;
            });
            
            const totalNodes = nodes.length;
            const totalLinks = links.length;
            
            document.getElementById('filterStats').textContent = 
                `–ü–æ–∫–∞–∑–∞–Ω–æ: ${visibleNodesCount}/${totalNodes} –∫–æ–Ω—Ü–µ–ø—Ü–∏–π, ${visibleLinksCount}/${totalLinks} —Å–≤—è–∑–µ–π`;
        }
        
        // –†–∞—Å—á–µ—Ç –≤–ª–∏—è—Ç–µ–ª—å–Ω–æ—Å—Ç–∏ –∫–æ–Ω—Ü–µ–ø—Ü–∏–π (degree centrality) —Å –∫—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ–º
        let influenceCache = null;
        
        function calculateInfluence() {
            if (influenceCache) return influenceCache;
            
            const influence = {};
            
            nodes.forEach(n => {
                influence[n.id] = { in: 0, out: 0, total: 0, node: n };
            });
            
            links.forEach(l => {
                const src = l.source.id || l.source;
                const tgt = l.target.id || l.target;
                influence[src].out++;
                influence[tgt].in++;
                if (l.bidirectional) {
                    influence[src].in++;
                    influence[tgt].out++;
                }
            });
            
            Object.values(influence).forEach(i => {
                i.total = i.in + i.out;
            });
            
            const result = Object.values(influence).sort((a, b) => b.total - a.total);
            influenceCache = result;
            return result;
        }
        
        function invalidateInfluenceCache() {
            influenceCache = null;
        }
        
        // –†–∞—Å—á–µ—Ç —É–∑–ª–æ–≤-–º–æ—Å—Ç–æ–≤ (betweenness centrality - –ü–û–õ–ù–ê–Ø –≤–µ—Ä—Å–∏—è —Å –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ—Å—Ç—å—é)
        let betweennessCache = null;
        let betweennessCalculating = false;
        
        // –ê—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è –¥–ª—è –ø–æ–ª–Ω–æ–≥–æ —Ä–∞—Å—á—ë—Ç–∞ –±–µ–∑ –±–ª–æ–∫–∏—Ä–æ–≤–∫–∏ UI
        // –ü—Ä–∞–≤–∏–ª—å–Ω—ã–π —Ä–∞—Å—á—ë—Ç Betweenness Centrality (–∞–ª–≥–æ—Ä–∏—Ç–º –ë—Ä–∞–Ω–¥–µ—Å–∞)
        async function calculateBetweennessAsync(progressCallback) {
            if (betweennessCache) return betweennessCache;
            if (betweennessCalculating) return null;
            
            betweennessCalculating = true;
            const betweenness = {};
            nodes.forEach(n => betweenness[n.id] = 0);
            
            let processedNodes = 0;
            const totalNodes = nodes.length;
            
            // –î–ª—è –∫–∞–∂–¥–æ–≥–æ –∏—Å—Ö–æ–¥–Ω–æ–≥–æ —É–∑–ª–∞
            for (let sourceIdx = 0; sourceIdx < nodes.length; sourceIdx++) {
                const source = nodes[sourceIdx];
                
                const S = []; // –°—Ç–µ–∫ —É–∑–ª–æ–≤ –≤ –ø–æ—Ä—è–¥–∫–µ –Ω–µ–≤–æ–∑—Ä–∞—Å—Ç–∞—é—â–µ–≥–æ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏—è
                const P = {}; // –ü—Ä–µ–¥—à–µ—Å—Ç–≤–µ–Ω–Ω–∏–∫–∏ –Ω–∞ –∫—Ä–∞—Ç—á–∞–π—à–∏—Ö –ø—É—Ç—è—Ö
                const sigma = {}; // –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –∫—Ä–∞—Ç—á–∞–π—à–∏—Ö –ø—É—Ç–µ–π
                const d = {}; // –†–∞—Å—Å—Ç–æ—è–Ω–∏—è
                const delta = {}; // –ó–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏
                
                nodes.forEach(n => {
                    P[n.id] = [];
                    sigma[n.id] = 0;
                    d[n.id] = -1;
                    delta[n.id] = 0;
                });
                
                sigma[source.id] = 1;
                d[source.id] = 0;
                
                const Q = [source.id];
                
                // BFS –¥–ª—è –ø–æ–∏—Å–∫–∞ –∫—Ä–∞—Ç—á–∞–π—à–∏—Ö –ø—É—Ç–µ–π
                while (Q.length > 0) {
                    const v = Q.shift();
                    S.push(v);
                    
                    // –î–ª—è –∫–∞–∂–¥–æ–≥–æ —Å–æ—Å–µ–¥–∞ v
                    links.forEach(link => {
                        const src = link.source.id || link.source;
                        const tgt = link.target.id || link.target;
                        
                        let w = null;
                        
                        // –£—á–∏—Ç—ã–≤–∞–µ–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–Ω–æ—Å—Ç—å –≥—Ä–∞—Ñ–∞
                        if (respectDirection) {
                            if (src === v) {
                                w = tgt;
                            } else if (link.bidirectional && tgt === v) {
                                w = src;
                            }
                        } else {
                            // –ù–µ–Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–π –≥—Ä–∞—Ñ
                            if (src === v) {
                                w = tgt;
                            } else if (tgt === v) {
                                w = src;
                            }
                        }
                        
                        if (w !== null) {
                            // –í–µ—Å —Å–≤—è–∑–∏ (–µ—Å–ª–∏ useWeightedPaths = true)
                            const weight = useWeightedPaths ? (4 - (link.weight || 2)) : 1;
                            
                            // –ü—É—Ç—å –∫ w –Ω–∞–π–¥–µ–Ω –≤–ø–µ—Ä–≤—ã–µ?
                            if (d[w] < 0) {
                                Q.push(w);
                                d[w] = d[v] + weight;
                            }
                            
                            // –ö—Ä–∞—Ç—á–∞–π—à–∏–π –ø—É—Ç—å –∫ w —á–µ—Ä–µ–∑ v?
                            if (d[w] === d[v] + weight) {
                                sigma[w] += sigma[v];
                                P[w].push(v);
                            }
                        }
                    });
                }
                
                // –ù–∞–∫–æ–ø–ª–µ–Ω–∏–µ (–æ–±—Ä–∞—Ç–Ω—ã–π –ø—Ä–æ—Ö–æ–¥)
                while (S.length > 0) {
                    const w = S.pop();
                    P[w].forEach(v => {
                        delta[v] += (sigma[v] / sigma[w]) * (1 + delta[w]);
                    });
                    if (w !== source.id) {
                        betweenness[w] += delta[w];
                    }
                }
                
                processedNodes++;
                
                // –û–±–Ω–æ–≤–ª—è–µ–º –ø—Ä–æ–≥—Ä–µ—Å—Å –∫–∞–∂–¥—ã–µ 5 —É–∑–ª–æ–≤
                if (processedNodes % 5 === 0) {
                    if (progressCallback) {
                        progressCallback(processedNodes, totalNodes);
                    }
                    await new Promise(resolve => setTimeout(resolve, 0));
                }
            }
            
            // –ù–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è
            const normFactor = respectDirection ? 1.0 : 2.0;
            Object.keys(betweenness).forEach(key => {
                betweenness[key] /= normFactor;
            });
            
            const result = Object.entries(betweenness)
                .map(([id, value]) => ({
                    node: nodes.find(n => n.id === id),
                    value: value,
                    count: Math.round(value)
                }))
                .sort((a, b) => b.value - a.value);
            
            betweennessCache = result;
            betweennessCalculating = false;
            
            if (progressCallback) {
                progressCallback(totalNodes, totalNodes);
            }
            
            return result;
        }
        
        // –°–∏–Ω—Ö—Ä–æ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è –¥–ª—è –æ–±—Ä–∞—Ç–Ω–æ–π —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏ (–≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∫—ç—à –∏–ª–∏ null)
        function calculateBetweenness() {
            if (betweennessCache) return betweennessCache;
            
            // –ï—Å–ª–∏ –∫—ç—à–∞ –Ω–µ—Ç - –∑–∞–ø—É—Å–∫–∞–µ–º –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω—ã–π —Ä–∞—Å—á—ë—Ç
            if (!betweennessCalculating) {
                calculateBetweennessAsync();
            }
            
            return null; // –í–µ—Ä–Ω—ë–º null, –ø–æ–∫–∞ –∏–¥—ë—Ç —Ä–∞—Å—á—ë—Ç
        }
        
        // –°–±—Ä–æ—Å –∫—ç—à–∞ –ø—Ä–∏ –∏–∑–º–µ–Ω–µ–Ω–∏–∏ –≥—Ä–∞—Ñ–∞
        function invalidateBetweennessCache() {
            betweennessCache = null;
            betweennessCalculating = false;
        }
        
        // –ö—ç—à –¥–ª—è PageRank
        let pageRankCache = null;
        let pageRankCalculating = false;
        
        function calculatePageRank(iterations = 20, dampingFactor = 0.85, progressCallback = null) {
            if (pageRankCache) return Promise.resolve(pageRankCache);
            if (pageRankCalculating) return Promise.resolve(null);
            
            pageRankCalculating = true;
            
            return new Promise(async (resolve) => {
                const pageRank = {};
                const inLinks = {};
                const outDegree = {};
                
                // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
                nodes.forEach(n => {
                    pageRank[n.id] = 1.0 / nodes.length;
                    inLinks[n.id] = [];
                    outDegree[n.id] = 0;
                });
                
                // –ü–æ—Å—Ç—Ä–æ–∏—Ç—å —Å–ø–∏—Å–∫–∏ –≤—Ö–æ–¥—è—â–∏—Ö —Å–≤—è–∑–µ–π –∏ –ø–æ–¥—Å—á–∏—Ç–∞—Ç—å –∏—Å—Ö–æ–¥—è—â–∏–µ
                links.forEach(link => {
                    const src = link.source.id || link.source;
                    const tgt = link.target.id || link.target;
                    const weight = useWeightedPaths ? (link.weight || 2) / 3.0 : 1.0;
                    
                    if (respectDirection) {
                        // –ù–∞–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–π –≥—Ä–∞—Ñ
                        inLinks[tgt].push({ from: src, weight: weight });
                        outDegree[src]++;
                        
                        if (link.bidirectional) {
                            inLinks[src].push({ from: tgt, weight: weight });
                            outDegree[tgt]++;
                        }
                    } else {
                        // –ù–µ–Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–π –≥—Ä–∞—Ñ
                        inLinks[tgt].push({ from: src, weight: weight });
                        inLinks[src].push({ from: tgt, weight: weight });
                        outDegree[src]++;
                        outDegree[tgt]++;
                    }
                });
                
                // –ò—Ç–µ—Ä–∞—Ç–∏–≤–Ω—ã–π —Ä–∞—Å—á–µ—Ç
                for (let iter = 0; iter < iterations; iter++) {
                    const newPageRank = {};
                    
                    nodes.forEach(node => {
                        let sum = 0;
                        
                        inLinks[node.id].forEach(inLink => {
                            if (outDegree[inLink.from] > 0) {
                                sum += (pageRank[inLink.from] / outDegree[inLink.from]) * inLink.weight;
                            }
                        });
                        
                        newPageRank[node.id] = (1 - dampingFactor) / nodes.length + dampingFactor * sum;
                    });
                    
                    // –û–±–Ω–æ–≤–∏—Ç—å –∑–Ω–∞—á–µ–Ω–∏—è
                    Object.keys(newPageRank).forEach(key => {
                        pageRank[key] = newPageRank[key];
                    });
                    
                    // –û–±–Ω–æ–≤–ª—è–µ–º –ø—Ä–æ–≥—Ä–µ—Å—Å
                    if (progressCallback && iter % 5 === 0) {
                        progressCallback(iter, iterations);
                        await new Promise(res => setTimeout(res, 0));
                    }
                }
                
                const result = Object.entries(pageRank)
                    .map(([id, value]) => ({
                        node: nodes.find(n => n.id === id),
                        value: value
                    }))
                    .sort((a, b) => b.value - a.value);
                
                pageRankCache = result;
                pageRankCalculating = false;
                
                if (progressCallback) progressCallback(iterations, iterations);
                
                resolve(result);
            });
        }
        
        function invalidatePageRankCache() {
            pageRankCache = null;
            pageRankCalculating = false;
        }
        
        // –ö—ç—à –¥–ª—è Closeness
        let closenessCache = null;
        let closenessCalculating = false;
        
        async function calculateClosenessCentrality(progressCallback = null) {
            if (closenessCache) return closenessCache;
            if (closenessCalculating) return null;
            
            closenessCalculating = true;
            const closeness = {};
            
            let processedNodes = 0;
            const totalNodes = nodes.length;
            
            for (let i = 0; i < nodes.length; i++) {
                const source = nodes[i];
                let totalDistance = 0;
                let reachableNodes = 0;
                
                for (let j = 0; j < nodes.length; j++) {
                    if (i === j) continue;
                    
                    const target = nodes[j];
                    // –ò—Å–ø–æ–ª—å–∑—É–µ–º –≥–ª–æ–±–∞–ª—å–Ω—ã–π –ø–∞—Ä–∞–º–µ—Ç—Ä respectDirection
                    const path = findShortestPath(source.id, target.id, false, respectDirection);
                    
                    if (path) {
                        // –î–ª—è –≤–∑–≤–µ—à–µ–Ω–Ω–æ–≥–æ –≥—Ä–∞—Ñ–∞ —Å—É–º–º–∏—Ä—É–µ–º –≤–µ—Å–∞
                        if (useWeightedPaths) {
                            let pathWeight = 0;
                            for (let k = 0; k < path.length - 1; k++) {
                                const link = links.find(l => {
                                    const src = l.source.id || l.source;
                                    const tgt = l.target.id || l.target;
                                    
                                    if (respectDirection) {
                                        return (src === path[k] && tgt === path[k + 1]) ||
                                               (l.bidirectional && tgt === path[k] && src === path[k + 1]);
                                    } else {
                                        return (src === path[k] && tgt === path[k + 1]) ||
                                               (tgt === path[k] && src === path[k + 1]);
                                    }
                                });
                                pathWeight += (4 - (link?.weight || 2));
                            }
                            totalDistance += pathWeight;
                        } else {
                            totalDistance += path.length - 1;
                        }
                        reachableNodes++;
                    }
                }
                
                // –ù–æ—Ä–º–∞–ª–∏–∑–æ–≤–∞–Ω–Ω–∞—è closeness (Wasserman & Faust)
                if (reachableNodes > 0) {
                    const rawCloseness = reachableNodes / totalDistance;
                    const normalizedCloseness = (reachableNodes / (nodes.length - 1)) * rawCloseness;
                    
                    closeness[source.id] = {
                        value: normalizedCloseness,
                        node: source,
                        reachable: reachableNodes
                    };
                } else {
                    closeness[source.id] = { value: 0, node: source, reachable: 0 };
                }
                
                processedNodes++;
                
                if (processedNodes % 5 === 0) {
                    if (progressCallback) {
                        progressCallback(processedNodes, totalNodes);
                    }
                    await new Promise(resolve => setTimeout(resolve, 0));
                }
            }
            
            const result = Object.values(closeness).sort((a, b) => b.value - a.value);
            closenessCache = result;
            closenessCalculating = false;
            
            if (progressCallback) progressCallback(totalNodes, totalNodes);
            
            return result;
        }
        
        function invalidateClosenessCache() {
            closenessCache = null;
            closenessCalculating = false;
        }
        
        // –ö—ç—à –¥–ª—è Clustering
        let clusteringCache = null;
        
        function calculateClusteringCoefficient() {
            if (clusteringCache) return clusteringCache;
            
            const clustering = {};
            
            nodes.forEach(node => {
                // –ù–∞–π—Ç–∏ –≤—Å–µ—Ö —Å–æ—Å–µ–¥–µ–π (–¥–ª—è –∫–ª–∞—Å—Ç–µ—Ä–∏–∑–∞—Ü–∏–∏ –≤—Å–µ–≥–¥–∞ –Ω–µ–Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–π –ø–æ–¥—Ö–æ–¥)
                const neighbors = new Set();
                links.forEach(link => {
                    const src = link.source.id || link.source;
                    const tgt = link.target.id || link.target;
                    
                    if (src === node.id) neighbors.add(tgt);
                    if (tgt === node.id || link.bidirectional) neighbors.add(src);
                });
                
                const k = neighbors.size;
                if (k < 2) {
                    clustering[node.id] = { value: 0, node: node, neighbors: k };
                    return;
                }
                
                // –ü–æ–¥—Å—á–∏—Ç–∞—Ç—å —Å–≤—è–∑–∏ –º–µ–∂–¥—É —Å–æ—Å–µ–¥—è–º–∏
                let edgesBetweenNeighbors = 0;
                const neighborArray = Array.from(neighbors);
                
                for (let i = 0; i < neighborArray.length; i++) {
                    for (let j = i + 1; j < neighborArray.length; j++) {
                        const hasEdge = links.some(link => {
                            const src = link.source.id || link.source;
                            const tgt = link.target.id || link.target;
                            return (src === neighborArray[i] && tgt === neighborArray[j]) ||
                                   (src === neighborArray[j] && tgt === neighborArray[i]) ||
                                   (link.bidirectional && 
                                    ((src === neighborArray[i] && tgt === neighborArray[j]) ||
                                     (src === neighborArray[j] && tgt === neighborArray[i])));
                        });
                        if (hasEdge) edgesBetweenNeighbors++;
                    }
                }
                
                clustering[node.id] = {
                    value: (2.0 * edgesBetweenNeighbors) / (k * (k - 1)),
                    node: node,
                    neighbors: k
                };
            });
            
            const result = Object.values(clustering).sort((a, b) => b.value - a.value);
            clusteringCache = result;
            return result;
        }
        
        function invalidateClusteringCache() {
            clusteringCache = null;
        }
        
        // –í–∑–≤–µ—à–µ–Ω–Ω–∞—è —Å—Ç–µ–ø–µ–Ω—å —É–∑–ª–∞
        function calculateWeightedDegree() {
            const weightedDegree = {};
            
            nodes.forEach(node => {
                let inWeight = 0;
                let outWeight = 0;
                let inCount = 0;
                let outCount = 0;
                
                links.forEach(link => {
                    const src = link.source.id || link.source;
                    const tgt = link.target.id || link.target;
                    const weight = useWeightedPaths ? (link.weight || 2) : 1;
                    
                    if (respectDirection) {
                        // –ù–∞–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–π –≥—Ä–∞—Ñ
                        if (tgt === node.id) {
                            inWeight += weight;
                            inCount++;
                        }
                        if (src === node.id) {
                            outWeight += weight;
                            outCount++;
                        }
                        if (link.bidirectional) {
                            if (src === node.id) {
                                inWeight += weight;
                                inCount++;
                            }
                            if (tgt === node.id) {
                                outWeight += weight;
                                outCount++;
                            }
                        }
                    } else {
                        // –ù–µ–Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–π –≥—Ä–∞—Ñ
                        if (tgt === node.id || src === node.id) {
                            inWeight += weight;
                            outWeight += weight;
                            inCount++;
                            outCount++;
                        }
                    }
                });
                
                weightedDegree[node.id] = {
                    inWeight: inWeight,
                    outWeight: outWeight,
                    totalWeight: respectDirection ? (inWeight + outWeight) : inWeight, // –î–ª—è –Ω–µ–Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–Ω–æ–≥–æ –Ω–µ —É–¥–≤–∞–∏–≤–∞–µ–º
                    inCount: inCount,
                    outCount: outCount,
                    totalCount: respectDirection ? (inCount + outCount) : inCount,
                    node: node
                };
            });
            
            return Object.values(weightedDegree).sort((a, b) => b.totalWeight - a.totalWeight);
        }
        
        // –ö—ç—à –¥–ª—è Eigenvector Centrality
        let eigenvectorCache = null;
        let eigenvectorCalculating = false;
        
        async function calculateEigenvectorCentrality(iterations = 100, progressCallback = null) {
            if (eigenvectorCache) return eigenvectorCache;
            if (eigenvectorCalculating) return null;
            
            eigenvectorCalculating = true;
            
            return new Promise(async (resolve) => {
                const eigenvector = {};
                
                // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Ä–∞–≤–Ω—ã–º–∏ –∑–Ω–∞—á–µ–Ω–∏—è–º–∏
                nodes.forEach(n => {
                    eigenvector[n.id] = 1.0 / Math.sqrt(nodes.length);
                });
                
                // –ü–æ—Å—Ç—Ä–æ–∏—Ç—å –º–∞—Ç—Ä–∏—Ü—É —Å–º–µ–∂–Ω–æ—Å—Ç–∏
                const adjacency = {};
                nodes.forEach(n => adjacency[n.id] = []);
                
                links.forEach(link => {
                    const src = link.source.id || link.source;
                    const tgt = link.target.id || link.target;
                    const weight = useWeightedPaths ? (link.weight || 2) / 3.0 : 1.0;
                    
                    if (respectDirection) {
                        // –ù–∞–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–π –≥—Ä–∞—Ñ - –≤—Ö–æ–¥—è—â–∏–µ —Å–≤—è–∑–∏
                        adjacency[tgt].push({ neighbor: src, weight: weight });
                        if (link.bidirectional) {
                            adjacency[src].push({ neighbor: tgt, weight: weight });
                        }
                    } else {
                        // –ù–µ–Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–π –≥—Ä–∞—Ñ
                        adjacency[src].push({ neighbor: tgt, weight: weight });
                        adjacency[tgt].push({ neighbor: src, weight: weight });
                    }
                });
                
                // Power iteration method
                for (let iter = 0; iter < iterations; iter++) {
                    const newEigenvector = {};
                    
                    // –í—ã—á–∏—Å–ª—è–µ–º –Ω–æ–≤—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è
                    nodes.forEach(node => {
                        let sum = 0;
                        adjacency[node.id].forEach(edge => {
                            sum += eigenvector[edge.neighbor] * edge.weight;
                        });
                        newEigenvector[node.id] = sum;
                    });
                    
                    // –ù–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è (L2 norm)
                    let norm = 0;
                    Object.values(newEigenvector).forEach(val => {
                        norm += val * val;
                    });
                    norm = Math.sqrt(norm);
                    
                    // –ò–∑–±–µ–≥–∞–µ–º –¥–µ–ª–µ–Ω–∏—è –Ω–∞ –Ω–æ–ª—å
                    if (norm < 1e-10) {
                        console.warn('Eigenvector: –Ω–æ—Ä–º–∞ —Å–ª–∏—à–∫–æ–º –º–∞–ª–∞, –ø—Ä–µ—Ä—ã–≤–∞–µ–º –∏—Ç–µ—Ä–∞—Ü–∏–∏');
                        break;
                    }
                    
                    Object.keys(newEigenvector).forEach(key => {
                        eigenvector[key] = newEigenvector[key] / norm;
                    });
                    
                    // –û–±–Ω–æ–≤–ª—è–µ–º –ø—Ä–æ–≥—Ä–µ—Å—Å
                    if (progressCallback && iter % 10 === 0) {
                        progressCallback(iter, iterations);
                        await new Promise(res => setTimeout(res, 0));
                    }
                }
                
                const result = Object.entries(eigenvector)
                    .map(([id, value]) => ({
                        node: nodes.find(n => n.id === id),
                        value: value
                    }))
                    .sort((a, b) => b.value - a.value);
                
                eigenvectorCache = result;
                eigenvectorCalculating = false;
                
                if (progressCallback) progressCallback(iterations, iterations);
                
                resolve(result);
            });
        }
        
        function invalidateEigenvectorCache() {
            eigenvectorCache = null;
            eigenvectorCalculating = false;
        }
        
        // –ü–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –¥–ª—è –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏–∏ —Ä–∞–∑–º–µ—Ä–æ–º
        let originalNodeRadii = {};
        let isVisualizingBySize = false;
        let currentVisualizedMetric = null;
        
        // –°–æ—Ö—Ä–∞–Ω–∏—Ç—å –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–µ —Ä–∞–¥–∏—É—Å—ã —É–∑–ª–æ–≤
        function saveOriginalRadii() {
            if (Object.keys(originalNodeRadii).length === 0) {
                nodes.forEach(n => {
                    originalNodeRadii[n.id] = 18; // –û—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–π —Ä–∞–¥–∏—É—Å
                });
            }
        }
        
        // –í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è –º–µ—Ç—Ä–∏–∫–∏ —Ä–∞–∑–º–µ—Ä–æ–º —É–∑–ª–æ–≤
        function visualizeMetricBySize(metricData, metricName) {
            if (!metricData || metricData.length === 0) {
                alert('–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏–∏');
                return;
            }
            
            saveOriginalRadii();
            
            isVisualizingBySize = true;
            currentVisualizedMetric = metricName;
            
            // –ù–∞–π—Ç–∏ –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–µ –∏ –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ
            const values = metricData.map(d => d.value || d.totalWeight || 0);
            const minValue = Math.min(...values);
            const maxValue = Math.max(...values);
            
            // –î–∏–∞–ø–∞–∑–æ–Ω —Ä–∞–¥–∏—É—Å–æ–≤: –æ—Ç 8 –¥–æ 35
            const minRadius = 8;
            const maxRadius = 35;
            
            // –°–æ–∑–¥–∞—Ç—å –º–∞–ø—É –∑–Ω–∞—á–µ–Ω–∏–π
            const valueMap = {};
            metricData.forEach(item => {
                const value = item.value || item.totalWeight || 0;
                // –ù–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è –≤ –¥–∏–∞–ø–∞–∑–æ–Ω —Ä–∞–¥–∏—É—Å–æ–≤
                let radius;
                if (maxValue === minValue) {
                    radius = (minRadius + maxRadius) / 2;
                } else {
                    radius = minRadius + ((value - minValue) / (maxValue - minValue)) * (maxRadius - minRadius);
                }
                valueMap[item.node.id] = radius;
            });
            
            // –ü—Ä–∏–º–µ–Ω–∏—Ç—å –Ω–æ–≤—ã–µ —Ä–∞–¥–∏—É—Å—ã
            node.selectAll("circle")
                .transition()
                .duration(500)
                .attr("r", d => valueMap[d.id] || minRadius);
            
            // –û–±–Ω–æ–≤–∏—Ç—å –ø–æ–∑–∏—Ü–∏—é —Ç–µ–∫—Å—Ç–∞
            node.selectAll("text")
                .transition()
                .duration(500)
                .attr("dy", d => -(valueMap[d.id] || minRadius) - 7);
            
            // –û–±–Ω–æ–≤–∏—Ç—å –º–∞—Ä–∫–µ—Ä—ã (—Å—Ç—Ä–µ–ª–∫–∏) - —É–≤–µ–ª–∏—á–∏—Ç—å refX –¥–ª—è –±–æ–ª—å—à–∏—Ö —É–∑–ª–æ–≤
            links.forEach((l, i) => {
                const tgt = l.target.id || l.target;
                const targetRadius = valueMap[tgt] || minRadius;
                
                link.filter((linkData, idx) => idx === i)
                    .attr("marker-end", d => {
                        // –°–æ–∑–¥–∞—ë–º –≤—Ä–µ–º–µ–Ω–Ω—ã–π –º–∞—Ä–∫–µ—Ä —Å –ø—Ä–∞–≤–∏–ª—å–Ω—ã–º refX
                        const markerId = `arrow-${d.type}-${i}`;
                        const existingMarker = defs.select(`#${markerId}`);
                        
                        if (existingMarker.empty()) {
                            const newMarker = defs.append("marker")
                                .attr("id", markerId)
                                .attr("viewBox", "0 -5 10 10")
                                .attr("refX", targetRadius + 8)
                                .attr("refY", 0)
                                .attr("markerWidth", 6)
                                .attr("markerHeight", 6)
                                .attr("orient", "auto")
                                .append("path")
                                .attr("d", "M0,-5L10,0L0,5")
                                .attr("fill", relationTypesObj[d.type].color);
                        } else {
                            existingMarker.attr("refX", targetRadius + 8);
                        }
                        
                        return `url(#${markerId})`;
                    });
            });
            
            // –û–±–Ω–æ–≤–∏—Ç—å –Ω–∞–¥–ø–∏—Å—å –∫–Ω–æ–ø–∫–∏
            const btn = document.getElementById('visualizeSizeBtn');
            if (btn) {
                btn.textContent = 'üîÑ –°–±—Ä–æ—Å–∏—Ç—å —Ä–∞–∑–º–µ—Ä—ã';
                btn.style.background = '#e74c3c';
            }
            
            console.log(`–í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è –º–µ—Ç—Ä–∏–∫–∏ "${metricName}" —Ä–∞–∑–º–µ—Ä–æ–º —É–∑–ª–æ–≤ –∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω–∞`);
        }
        
        // –í–æ—Å—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–µ —Ä–∞–∑–º–µ—Ä—ã
        function resetNodeSizes() {
            if (!isVisualizingBySize) return;
            
            isVisualizingBySize = false;
            currentVisualizedMetric = null;
            
            // –í–æ—Å—Å—Ç–∞–Ω–æ–≤–∏—Ç—å —Ä–∞–¥–∏—É—Å—ã
            node.selectAll("circle")
                .transition()
                .duration(500)
                .attr("r", 18);
            
            // –í–æ—Å—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –ø–æ–∑–∏—Ü–∏—é —Ç–µ–∫—Å—Ç–∞
            node.selectAll("text")
                .transition()
                .duration(500)
                .attr("dy", -25);
            
            // –í–æ—Å—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–µ –º–∞—Ä–∫–µ—Ä—ã
            link.attr("marker-end", d => `url(#arrow-${d.type})`);
            
            // –£–¥–∞–ª–∏—Ç—å –≤—Ä–µ–º–µ–Ω–Ω—ã–µ –º–∞—Ä–∫–µ—Ä—ã
            defs.selectAll("[id^='arrow-'][id$='-']").remove();
            
            // –û–±–Ω–æ–≤–∏—Ç—å –Ω–∞–¥–ø–∏—Å—å –∫–Ω–æ–ø–∫–∏
            const btn = document.getElementById('visualizeSizeBtn');
            if (btn) {
                btn.textContent = 'üìè –í–∏–∑—É–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å —Ä–∞–∑–º–µ—Ä–æ–º';
                btn.style.background = '#27ae60';
            }
            
            console.log('–û—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–µ —Ä–∞–∑–º–µ—Ä—ã —É–∑–ª–æ–≤ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã');
        }
        
        // –ü–µ—Ä–µ–∫–ª—é—á–∞—Ç–µ–ª—å –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏–∏
        function toggleVisualizationBySize() {
            if (isVisualizingBySize) {
                resetNodeSizes();
            } else {
                // –í–∏–∑—É–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å —Ç–µ–∫—É—â—É—é –º–µ—Ç—Ä–∏–∫—É
                if (!currentMetric) {
                    alert('–°–Ω–∞—á–∞–ª–∞ –≤—ã–±–µ—Ä–∏—Ç–µ –º–µ—Ç—Ä–∏–∫—É –∏–∑ —Ç–∞–±–æ–≤');
                    return;
                }
                
                let metricData = null;
                
                switch(currentMetric) {
                    case 'degree':
                        metricData = calculateWeightedDegree();
                        break;
                    case 'pagerank':
                        metricData = pageRankCache;
                        break;
                    case 'betweenness':
                        metricData = betweennessCache;
                        break;
                    case 'closeness':
                        metricData = closenessCache;
                        break;
                    case 'clustering':
                        metricData = clusteringCache;
                        break;
                    case 'eigenvector':
                        metricData = eigenvectorCache;
                        break;
                }
                
                if (!metricData) {
                    alert('–°–Ω–∞—á–∞–ª–∞ –∑–∞–ø—É—Å—Ç–∏—Ç–µ –∞–Ω–∞–ª–∏–∑ –¥–ª—è –≤—ã–±—Ä–∞–Ω–Ω–æ–π –º–µ—Ç—Ä–∏–∫–∏');
                    return;
                }
                
                visualizeMetricBySize(metricData, currentMetric);
            }
        }
        
        // –ü–æ–∏—Å–∫ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç —Å–≤—è–∑–Ω–æ—Å—Ç–∏
        function findConnectedComponents() {
            const visited = new Set();
            const components = [];
            
            nodes.forEach(node => {
                if (visited.has(node.id)) return;
                
                const component = [];
                const queue = [node.id];
                visited.add(node.id);
                
                while (queue.length > 0) {
                    const current = queue.shift();
                    component.push(current);
                    
                    links.forEach(link => {
                        const src = link.source.id || link.source;
                        const tgt = link.target.id || link.target;
                        
                        if (respectDirection) {
                            if (src === current && !visited.has(tgt)) {
                                visited.add(tgt);
                                queue.push(tgt);
                            } else if (link.bidirectional && tgt === current && !visited.has(src)) {
                                visited.add(src);
                                queue.push(src);
                            }
                        } else {
                            if (src === current && !visited.has(tgt)) {
                                visited.add(tgt);
                                queue.push(tgt);
                            } else if (tgt === current && !visited.has(src)) {
                                visited.add(src);
                                queue.push(src);
                            }
                        }
                    });
                }
                
                components.push(component);
            });
            
            return components;
        }
        
        // –†–∞—Å—á—ë—Ç –æ–±—â–µ–π —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –≥—Ä–∞—Ñ–∞
        async function calculateGraphStatistics(progressCallback = null) {
            const stats = {
                nodes: nodes.length,
                edges: links.length,
                density: 0,
                avgDegree: 0,
                diameter: 0,
                avgPathLength: 0,
                components: 0,
                avgClustering: 0,
                reciprocity: 0
            };
            
            // –ü–ª–æ—Ç–Ω–æ—Å—Ç—å
            const maxEdges = nodes.length * (nodes.length - 1);
            stats.density = (2 * links.length) / maxEdges;
            
            // –°—Ä–µ–¥–Ω—è—è —Å—Ç–µ–ø–µ–Ω—å
            const degrees = nodes.map(n => {
                let degree = 0;
                links.forEach(l => {
                    const src = l.source.id || l.source;
                    const tgt = l.target.id || l.target;
                    
                    if (respectDirection) {
                        if (src === n.id || tgt === n.id) degree++;
                        if (l.bidirectional && (src === n.id || tgt === n.id)) degree++;
                    } else {
                        if (src === n.id || tgt === n.id) degree++;
                    }
                });
                return degree;
            });
            stats.avgDegree = degrees.reduce((a, b) => a + b, 0) / degrees.length;
            
            // –í–∑–∞–∏–º–Ω–æ—Å—Ç—å (reciprocity)
            let bidirectionalCount = links.filter(l => l.bidirectional).length;
            stats.reciprocity = links.length > 0 ? bidirectionalCount / links.length : 0;
            
            if (progressCallback) progressCallback(1, 4);
            await new Promise(resolve => setTimeout(resolve, 0));
            
            // –î–∏–∞–º–µ—Ç—Ä –∏ —Å—Ä–µ–¥–Ω—è—è –¥–ª–∏–Ω–∞ –ø—É—Ç–∏
            let totalPaths = 0;
            let pathCount = 0;
            let maxPath = 0;
            
            for (let i = 0; i < nodes.length; i++) {
                for (let j = i + 1; j < nodes.length; j++) {
                    const path = findShortestPath(nodes[i].id, nodes[j].id, false, respectDirection);
                    if (path) {
                        const length = path.length - 1;
                        totalPaths += length;
                        pathCount++;
                        maxPath = Math.max(maxPath, length);
                    }
                }
            }
            
            stats.diameter = maxPath;
            stats.avgPathLength = pathCount > 0 ? totalPaths / pathCount : 0;
            
            if (progressCallback) progressCallback(2, 4);
            await new Promise(resolve => setTimeout(resolve, 0));
            
            // –°—Ä–µ–¥–Ω–∏–π –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç –∫–ª–∞—Å—Ç–µ—Ä–∏–∑–∞—Ü–∏–∏
            const clustering = calculateClusteringCoefficient();
            stats.avgClustering = clustering.reduce((sum, c) => sum + c.value, 0) / clustering.length;
            
            if (progressCallback) progressCallback(3, 4);
            await new Promise(resolve => setTimeout(resolve, 0));
            
            // –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç —Å–≤—è–∑–Ω–æ—Å—Ç–∏
            stats.components = findConnectedComponents().length;
            
            if (progressCallback) progressCallback(4, 4);
            
            return stats;
        }
        
        // –û–ø–∏—Å–∞–Ω–∏—è –∏ –∏–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∞—Ü–∏–∏ –º–µ—Ç—Ä–∏–∫
        const metricDescriptions = {
            degree: {
                name: "–°—Ç–µ–ø–µ–Ω—å —É–∑–ª–∞ (Degree Centrality)",
                description: "–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–≤—è–∑–µ–π —É–∑–ª–∞ —Å –¥—Ä—É–≥–∏–º–∏ —É–∑–ª–∞–º–∏",
                interpretation: () => {
                    if (respectDirection && useWeightedPaths) {
                        return "–í –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–Ω–æ–º –≤–∑–≤–µ—à–µ–Ω–Ω–æ–º –≥—Ä–∞—Ñ–µ: –≤—ã—Å–æ–∫–∏–π –≤—Ö–æ–¥—è—â–∏–π –≤–µ—Å = –∫–æ–Ω—Ü–µ–ø—Ü–∏—é —á–∞—Å—Ç–æ —Ü–∏—Ç–∏—Ä—É—é—Ç —á–µ—Ä–µ–∑ —Å–∏–ª—å–Ω—ã–µ —Å–≤—è–∑–∏, –≤—ã—Å–æ–∫–∏–π –∏—Å—Ö–æ–¥—è—â–∏–π = –∫–æ–Ω—Ü–µ–ø—Ü–∏—è –æ–∫–∞–∑—ã–≤–∞–µ—Ç —Å–∏–ª—å–Ω–æ–µ –≤–ª–∏—è–Ω–∏–µ –Ω–∞ –¥—Ä—É–≥–∏–µ.";
                    } else if (respectDirection && !useWeightedPaths) {
                        return "–í –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–Ω–æ–º –≥—Ä–∞—Ñ–µ: –≤—ã—Å–æ–∫–∏–µ –≤—Ö–æ–¥—è—â–∏–µ —Å–≤—è–∑–∏ = –Ω–∞ –∫–æ–Ω—Ü–µ–ø—Ü–∏—é —á–∞—Å—Ç–æ —Å—Å—ã–ª–∞—é—Ç—Å—è, –≤—ã—Å–æ–∫–∏–µ –∏—Å—Ö–æ–¥—è—â–∏–µ = –∫–æ–Ω—Ü–µ–ø—Ü–∏—è –∞–∫—Ç–∏–≤–Ω–æ –≤–ª–∏—è–µ—Ç –Ω–∞ –¥—Ä—É–≥–∏–µ. –°–∏–ª–∞ —Å–≤—è–∑–µ–π –Ω–µ —É—á–∏—Ç—ã–≤–∞–µ—Ç—Å—è.";
                    } else if (!respectDirection && useWeightedPaths) {
                        return "–í –Ω–µ–Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–Ω–æ–º –≤–∑–≤–µ—à–µ–Ω–Ω–æ–º –≥—Ä–∞—Ñ–µ: –≤—ã—Å–æ–∫–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ = –∫–æ–Ω—Ü–µ–ø—Ü–∏—è —Å–≤—è–∑–∞–Ω–∞ —Å–æ –º–Ω–æ–≥–∏–º–∏ –∏–¥–µ—è–º–∏ —Å–∏–ª—å–Ω—ã–º–∏ —Å–≤—è–∑—è–º–∏. –ß–µ–º –±–æ–ª—å—à–µ –≤–µ—Å —Å–≤—è–∑–µ–π, —Ç–µ–º –≤–∞–∂–Ω–µ–µ –∫–æ–Ω—Ü–µ–ø—Ü–∏—è.";
                    } else {
                        return "–í –Ω–µ–Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–Ω–æ–º –≥—Ä–∞—Ñ–µ: –≤—ã—Å–æ–∫–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ = –∫–æ–Ω—Ü–µ–ø—Ü–∏—è —Å–≤—è–∑–∞–Ω–∞ —Å–æ –º–Ω–æ–≥–∏–º–∏ –∏–¥–µ—è–º–∏. –≠—Ç–æ \"—Ö–∞–±—ã\" —Ñ–∏–ª–æ—Å–æ—Ñ—Å–∫–æ–π —Å–µ—Ç–∏. –í—Å–µ —Å–≤—è–∑–∏ —Å—á–∏—Ç–∞—é—Ç—Å—è –æ–¥–∏–Ω–∞–∫–æ–≤–æ –≤–∞–∂–Ω—ã–º–∏.";
                    }
                },
                usage: "–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –¥–ª—è –≤—ã—è–≤–ª–µ–Ω–∏—è –Ω–∞–∏–±–æ–ª–µ–µ –∞–∫—Ç–∏–≤–Ω–æ –∏—Å–ø–æ–ª—å–∑—É–µ–º—ã—Ö –∫–æ–Ω—Ü–µ–ø—Ü–∏–π, –≤–æ–∫—Ä—É–≥ –∫–æ—Ç–æ—Ä—ã—Ö —Å—Ç—Ä–æ—è—Ç—Å—è —Ñ–∏–ª–æ—Å–æ—Ñ—Å–∫–∏–µ —Å–∏—Å—Ç–µ–º—ã.",
                formula: () => useWeightedPaths ? "Œ£ –≤–µ—Å–æ–≤ –≤—Å–µ—Ö —Å–≤—è–∑–µ–π —É–∑–ª–∞" : "–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ä—ë–±–µ—Ä, –∏–Ω—Ü–∏–¥–µ–Ω—Ç–Ω—ã—Ö —É–∑–ª—É"
            },
            
            pagerank: {
                name: "PageRank",
                description: "–ê–≤—Ç–æ—Ä–∏—Ç–µ—Ç–Ω–æ—Å—Ç—å —É–∑–ª–∞ —á–µ—Ä–µ–∑ –∫–∞—á–µ—Å—Ç–≤–æ –≤—Ö–æ–¥—è—â–∏—Ö —Å–≤—è–∑–µ–π",
                interpretation: () => {
                    if (respectDirection && useWeightedPaths) {
                        return "–ù–∞–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–π –≤–∑–≤–µ—à–µ–Ω–Ω—ã–π: –∫–æ–Ω—Ü–µ–ø—Ü–∏—è –ø–æ–ª—É—á–∞–µ—Ç –±–æ–ª—å—à–µ –∞–≤—Ç–æ—Ä–∏—Ç–µ—Ç–∞ –æ—Ç –≤–∞–∂–Ω—ã—Ö —É–∑–ª–æ–≤ —á–µ—Ä–µ–∑ —Å–∏–ª—å–Ω—ã–µ —Å–≤—è–∑–∏. –§—É–Ω–¥–∞–º–µ–Ω—Ç–∞–ª—å–Ω–æ–µ –≤–ª–∏—è–Ω–∏–µ (–≤–µ—Å 3) –ø–µ—Ä–µ–¥–∞—ë—Ç –±–æ–ª—å—à–µ –∞–≤—Ç–æ—Ä–∏—Ç–µ—Ç–∞, —á–µ–º —Å–ª–∞–±–æ–µ —É–ø–æ–º–∏–Ω–∞–Ω–∏–µ (–≤–µ—Å 1).";
                    } else if (respectDirection && !useWeightedPaths) {
                        return "–ù–∞–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–π: –∫–æ–Ω—Ü–µ–ø—Ü–∏—è –≤–∞–∂–Ω–∞, –µ—Å–ª–∏ –Ω–∞ –Ω–µ—ë —Å—Å—ã–ª–∞—é—Ç—Å—è –¥—Ä—É–≥–∏–µ –≤–ª–∏—è—Ç–µ–ª—å–Ω—ã–µ –∏–¥–µ–∏. –í—Å–µ —Å–≤—è–∑–∏ —Å—á–∏—Ç–∞—é—Ç—Å—è —Ä–∞–≤–Ω—ã–º–∏ –ø–æ —Å–∏–ª–µ.";
                    } else if (!respectDirection && useWeightedPaths) {
                        return "–ù–µ–Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–π –≤–∑–≤–µ—à–µ–Ω–Ω—ã–π: –∫–æ–Ω—Ü–µ–ø—Ü–∏—è –≤–∞–∂–Ω–∞ —á–µ—Ä–µ–∑ —Å–∏–ª—å–Ω—ã–µ —Å–≤—è–∑–∏ —Å –¥—Ä—É–≥–∏–º–∏ –≤–∞–∂–Ω—ã–º–∏ –∫–æ–Ω—Ü–µ–ø—Ü–∏—è–º–∏. –°–∏–º–º–µ—Ç—Ä–∏—á–Ω–æ–µ –≤–∑–∞–∏–º–Ω–æ–µ —É—Å–∏–ª–µ–Ω–∏–µ.";
                    } else {
                        return "–ù–µ–Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–π: –∫–æ–Ω—Ü–µ–ø—Ü–∏—è –≤–∞–∂–Ω–∞, –µ—Å–ª–∏ —Å–≤—è–∑–∞–Ω–∞ —Å –¥—Ä—É–≥–∏–º–∏ –≤–∞–∂–Ω—ã–º–∏ –∫–æ–Ω—Ü–µ–ø—Ü–∏—è–º–∏. –°–∏–º–º–µ—Ç—Ä–∏—á–Ω–∞—è –≤–µ—Ä—Å–∏—è –±–µ–∑ —É—á—ë—Ç–∞ —Å–∏–ª—ã –∏ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏—è —Å–≤—è–∑–µ–π.";
                    }
                },
                usage: "–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –¥–ª—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –∫–æ–Ω—Ü–µ–ø—Ü–∏–π, –∫–æ—Ç–æ—Ä—ã–µ –ø–æ–ª—É—á–∞—é—Ç –≤–ª–∏—è–Ω–∏–µ –æ—Ç –¥—Ä—É–≥–∏—Ö –≤–∞–∂–Ω—ã—Ö –∏–¥–µ–π. –û—Ç–ª–∏—á–∞–µ—Ç—Å—è –æ—Ç Degree —Ç–µ–º, —á—Ç–æ —É—á–∏—Ç—ã–≤–∞–µ—Ç –Ω–µ —Ç–æ–ª—å–∫–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ, –Ω–æ –∏ –≤–∞–∂–Ω–æ—Å—Ç—å —Å–æ—Å–µ–¥–µ–π.",
                formula: () => "PR(A) = (1-d)/N + d √ó Œ£(PR(Ti)/C(Ti))" + (useWeightedPaths ? " √ó w(Ti,A)" : "")
            },
            
            betweenness: {
                name: "Betweenness Centrality (–ü–æ—Å—Ä–µ–¥–Ω–∏—á–µ—Å—Ç–≤–æ)",
                description: "–ß–∞—Å—Ç–æ—Ç–∞ –Ω–∞—Ö–æ–∂–¥–µ–Ω–∏—è —É–∑–ª–∞ –Ω–∞ –∫—Ä–∞—Ç—á–∞–π—à–∏—Ö –ø—É—Ç—è—Ö –º–µ–∂–¥—É –¥—Ä—É–≥–∏–º–∏ —É–∑–ª–∞–º–∏",
                interpretation: () => {
                    if (respectDirection && useWeightedPaths) {
                        return "–ù–∞–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–π –≤–∑–≤–µ—à–µ–Ω–Ω—ã–π: –∫–æ–Ω—Ü–µ–ø—Ü–∏–∏-–º–æ—Å—Ç—ã, —á–µ—Ä–µ–∑ –∫–æ—Ç–æ—Ä—ã–µ –ø—Ä–æ—Ö–æ–¥–∏—Ç –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–Ω–æ–µ –≤–ª–∏—è–Ω–∏–µ –ø–æ –Ω–∞–∏–±–æ–ª–µ–µ —Å–∏–ª—å–Ω—ã–º —Å–≤—è–∑—è–º. –ê–ª–≥–æ—Ä–∏—Ç–º –ø—Ä–µ–¥–ø–æ—á–∏—Ç–∞–µ—Ç –ø—É—Ç–∏ —Å –≤—ã—Å–æ–∫–∏–º–∏ –≤–µ—Å–∞–º–∏.";
                    } else if (respectDirection && !useWeightedPaths) {
                        return "–ù–∞–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–π: –∫–æ–Ω—Ü–µ–ø—Ü–∏–∏-–º–æ—Å—Ç—ã –¥–ª—è –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–Ω–æ–≥–æ –≤–ª–∏—è–Ω–∏—è. –ü—É—Ç—å –≤—ã–±–∏—Ä–∞–µ—Ç—Å—è –ø–æ –º–∏–Ω–∏–º—É–º—É —Ä—ë–±–µ—Ä, —Å–∏–ª–∞ —Å–≤—è–∑–µ–π –Ω–µ –≤–∞–∂–Ω–∞.";
                    } else if (!respectDirection && useWeightedPaths) {
                        return "–ù–µ–Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–π –≤–∑–≤–µ—à–µ–Ω–Ω—ã–π: –∫–æ–Ω—Ü–µ–ø—Ü–∏–∏-–º–æ—Å—Ç—ã –º–µ–∂–¥—É —Ç—Ä–∞–¥–∏—Ü–∏—è–º–∏. –ò–¥–µ–∏ —Ä–∞—Å–ø—Ä–æ—Å—Ç—Ä–∞–Ω—è—é—Ç—Å—è —á–µ—Ä–µ–∑ —Å–∏–ª—å–Ω—ã–µ —Å–≤—è–∑–∏ ‚Äî —Ñ—É–Ω–¥–∞–º–µ–Ω—Ç–∞–ª—å–Ω—ã–µ –≤–ª–∏—è–Ω–∏—è –≤–∞–∂–Ω–µ–µ —Å–ª–∞–±—ã—Ö —É–ø–æ–º–∏–Ω–∞–Ω–∏–π.";
                    } else {
                        return "–ù–µ–Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–π: –∫–æ–Ω—Ü–µ–ø—Ü–∏–∏-–º–æ—Å—Ç—ã –º–µ–∂–¥—É —Ç—Ä–∞–¥–∏—Ü–∏—è–º–∏. –ü—É—Ç—å –æ–ø—Ä–µ–¥–µ–ª—è–µ—Ç—Å—è –º–∏–Ω–∏–º—É–º–æ–º —à–∞–≥–æ–≤, –≤—Å–µ —Å–≤—è–∑–∏ —Ä–∞–≤–Ω–æ–∑–Ω–∞—á–Ω—ã.";
                    }
                },
                usage: "–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –¥–ª—è –ø–æ–∏—Å–∫–∞ –∫–æ–Ω—Ü–µ–ø—Ü–∏–π, –∫–æ—Ç–æ—Ä—ã–µ —Å–æ–µ–¥–∏–Ω—è—é—Ç —Ä–∞–∑–ª–∏—á–Ω—ã–µ —Ñ–∏–ª–æ—Å–æ—Ñ—Å–∫–∏–µ —à–∫–æ–ª—ã. –£–¥–∞–ª–µ–Ω–∏–µ —Ç–∞–∫–∏—Ö —É–∑–ª–æ–≤ –º–æ–∂–µ—Ç —Ä–∞–∑–±–∏—Ç—å –≥—Ä–∞—Ñ –Ω–∞ –∏–∑–æ–ª–∏—Ä–æ–≤–∞–Ω–Ω—ã–µ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã.",
                formula: () => {
                    const base = "CB(v) = Œ£(œÉst(v)/œÉst), –≥–¥–µ œÉst ‚Äî —á–∏—Å–ª–æ –∫—Ä–∞—Ç—á–∞–π—à–∏—Ö –ø—É—Ç–µ–π";
                    return base + (useWeightedPaths ? " (—Å —É—á—ë—Ç–æ–º –≤–µ—Å–æ–≤ ‚Äî –º–∏–Ω–∏–º—É–º '—Å—Ç–æ–∏–º–æ—Å—Ç–∏')" : " (–º–∏–Ω–∏–º—É–º —Ä—ë–±–µ—Ä)");
                }
            },
            
            closeness: {
                name: "Closeness Centrality (–ë–ª–∏–∑–æ—Å—Ç—å)",
                description: "–û–±—Ä–∞—Ç–Ω–æ–µ —Å—Ä–µ–¥–Ω–µ–µ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ –æ—Ç —É–∑–ª–∞ –¥–æ –≤—Å–µ—Ö –æ—Å—Ç–∞–ª—å–Ω—ã—Ö —É–∑–ª–æ–≤",
                interpretation: () => {
                    if (respectDirection && useWeightedPaths) {
                        return "–ù–∞–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–π –≤–∑–≤–µ—à–µ–Ω–Ω—ã–π: –∫–æ–Ω—Ü–µ–ø—Ü–∏—è –≤ —Ü–µ–Ω—Ç—Ä–µ –ø–æ—Ç–æ–∫–∞ –≤–ª–∏—è–Ω–∏—è. –ú–æ–∂–µ—Ç –±—ã—Å—Ç—Ä–æ ¬´–¥–æ—Å—Ç—É—á–∞—Ç—å—Å—è¬ª –¥–æ –¥—Ä—É–≥–∏—Ö –∏–¥–µ–π –ø–æ —Å–∏–ª—å–Ω—ã–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–º —Å–≤—è–∑—è–º. –§—É–Ω–¥–∞–º–µ–Ω—Ç–∞–ª—å–Ω—ã–µ —Å–≤—è–∑–∏ —Å–æ–∫—Ä–∞—â–∞—é—Ç '—Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ'.";
                    } else if (respectDirection && !useWeightedPaths) {
                        return "–ù–∞–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–π: –∏–∑ –∫–æ–Ω—Ü–µ–ø—Ü–∏–∏ –º–æ–∂–Ω–æ –±—ã—Å—Ç—Ä–æ –¥–æ—Å—Ç–∏—á—å –¥—Ä—É–≥–∏—Ö –∏–¥–µ–π –ø–æ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–º —Å–≤—è–∑—è–º. –†–∞—Å—Å—Ç–æ—è–Ω–∏–µ = —á–∏—Å–ª–æ —à–∞–≥–æ–≤.";
                    } else if (!respectDirection && useWeightedPaths) {
                        return "–ù–µ–Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–π –≤–∑–≤–µ—à–µ–Ω–Ω—ã–π: –∫–æ–Ω—Ü–µ–ø—Ü–∏—è –≤ —Å–∞–º–æ–º —Ü–µ–Ω—Ç—Ä–µ —Å–µ—Ç–∏ –≤–∑–∞–∏–º–æ–≤–ª–∏—è–Ω–∏–π. –°–∏–ª—å–Ω—ã–µ —Å–≤—è–∑–∏ –¥–µ–ª–∞—é—Ç –µ—ë –±–æ–ª–µ–µ '–±–ª–∏–∑–∫–æ–π' –∫–æ –≤—Å–µ–º –æ—Å—Ç–∞–ª—å–Ω—ã–º –∏–¥–µ—è–º.";
                    } else {
                        return "–ù–µ–Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–π: –∫–æ–Ω—Ü–µ–ø—Ü–∏—è –≤ —Ü–µ–Ω—Ç—Ä–µ —Å–µ—Ç–∏. –ú–æ–∂–µ—Ç –¥–æ—Å—Ç–∏—á—å –ª—é–±–æ–π –¥—Ä—É–≥–æ–π –∏–¥–µ–∏ –∑–∞ –º–∏–Ω–∏–º—É–º —à–∞–≥–æ–≤, –Ω–µ–∑–∞–≤–∏—Å–∏–º–æ –æ—Ç —Å–∏–ª—ã —Å–≤—è–∑–µ–π.";
                    }
                },
                usage: "–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –¥–ª—è –≤—ã—è–≤–ª–µ–Ω–∏—è –∫–æ–Ω—Ü–µ–ø—Ü–∏–π, –∫–æ—Ç–æ—Ä—ã–µ –º–æ–≥—É—Ç —Å–ª—É–∂–∏—Ç—å –æ—Ç–ø—Ä–∞–≤–Ω–æ–π —Ç–æ—á–∫–æ–π –¥–ª—è –ø–æ–Ω–∏–º–∞–Ω–∏—è –≤—Å–µ–π —Ñ–∏–ª–æ—Å–æ—Ñ—Å–∫–æ–π —Å–∏—Å—Ç–µ–º—ã. –û–Ω–∏ –Ω–∞–∏–±–æ–ª–µ–µ ¬´–¥–æ—Å—Ç—É–ø–Ω—ã¬ª –∏–∑ –ª—é–±–æ–π —á–∞—Å—Ç–∏ —Å–µ—Ç–∏.",
                formula: () => {
                    const base = "CC(v) = (n-1) / Œ£d(v,u), –≥–¥–µ d(v,u) ‚Äî —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ";
                    return base + (useWeightedPaths ? " (–≤–∑–≤–µ—à–µ–Ω–Ω–æ–µ)" : " (–ø–æ —á–∏—Å–ª—É —Ä—ë–±–µ—Ä)");
                }
            },
            
            clustering: {
                name: "Clustering Coefficient (–ö–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç –∫–ª–∞—Å—Ç–µ—Ä–∏–∑–∞—Ü–∏–∏)",
                description: "–°—Ç–µ–ø–µ–Ω—å, –≤ –∫–æ—Ç–æ—Ä–æ–π —Å–æ—Å–µ–¥–∏ —É–∑–ª–∞ —Å–≤—è–∑–∞–Ω—ã –º–µ–∂–¥—É —Å–æ–±–æ–π",
                interpretation: () => {
                    return "–í—ã—Å–æ–∫–∏–π –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç = –∫–æ–Ω—Ü–µ–ø—Ü–∏—è –≤ –ø–ª–æ—Ç–Ω–æ–º –∫–ª–∞—Å—Ç–µ—Ä–µ –≤–∑–∞–∏–º–æ—Å–≤—è–∑–∞–Ω–Ω—ã—Ö –∏–¥–µ–π (—Ñ–∏–ª–æ—Å–æ—Ñ—Å–∫–∞—è —à–∫–æ–ª–∞). –ù–∏–∑–∫–∏–π = —Å–æ–µ–¥–∏–Ω—è–µ—Ç —Ä–∞–∑–Ω—ã–µ –≥—Ä—É–ø–ø—ã. –ú–µ—Ç—Ä–∏–∫–∞ –≤—Å–µ–≥–¥–∞ –Ω–µ–Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–Ω–∞—è –ø–æ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—é, –≤–µ—Å–∞ –Ω–µ –≤–ª–∏—è—é—Ç –Ω–∞ —Ä–∞—Å—á—ë—Ç.";
                },
                usage: "–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –¥–ª—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ –∫–æ–Ω—Ü–µ–ø—Ü–∏—è —á–∞—Å—Ç—å—é —Ç–µ—Å–Ω–æ —Å–≤—è–∑–∞–Ω–Ω–æ–π —Ñ–∏–ª–æ—Å–æ—Ñ—Å–∫–æ–π —à–∫–æ–ª—ã (–≤—ã—Å–æ–∫–∏–π –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç) –∏–ª–∏ —Å–ª—É–∂–∏—Ç –º–æ—Å—Ç–æ–º –º–µ–∂–¥—É —Ä–∞–∑–Ω—ã–º–∏ —Ç—Ä–∞–¥–∏—Ü–∏—è–º–∏ (–Ω–∏–∑–∫–∏–π –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç).",
                formula: () => "C(v) = 2e(v) / (k(v)(k(v)-1)), –≥–¥–µ e(v) ‚Äî —Ä—ë–±—Ä–∞ –º–µ–∂–¥—É —Å–æ—Å–µ–¥—è–º–∏"
            },
            
            eigenvector: {
                name: "Eigenvector Centrality",
                description: "–í–ª–∏—è—Ç–µ–ª—å–Ω–æ—Å—Ç—å —É–∑–ª–∞ —á–µ—Ä–µ–∑ —Å–≤—è–∑–∏ —Å –¥—Ä—É–≥–∏–º–∏ –≤–ª–∏—è—Ç–µ–ª—å–Ω—ã–º–∏ —É–∑–ª–∞–º–∏",
                interpretation: () => {
                    if (respectDirection && useWeightedPaths) {
                        return "–ù–∞–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–π –≤–∑–≤–µ—à–µ–Ω–Ω—ã–π: –∫–æ–Ω—Ü–µ–ø—Ü–∏—è –≤–∞–∂–Ω–∞, –µ—Å–ª–∏ –Ω–∞ –Ω–µ—ë —Å–∏–ª—å–Ω–æ –≤–ª–∏—è—é—Ç –¥—Ä—É–≥–∏–µ –≤–∞–∂–Ω—ã–µ –∫–æ–Ω—Ü–µ–ø—Ü–∏–∏. –í—Ö–æ–¥—è—â–∞—è —Å–≤—è–∑—å –æ—Ç –≤–ª–∏—è—Ç–µ–ª—å–Ω–æ–≥–æ —É–∑–ª–∞ —Å –≤–µ—Å–æ–º 3 –¥–∞—ë—Ç –±–æ–ª—å—à–µ '–æ—á–∫–æ–≤', —á–µ–º —Å –≤–µ—Å–æ–º 1.";
                    } else if (respectDirection && !useWeightedPaths) {
                        return "–ù–∞–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–π: –∫–æ–Ω—Ü–µ–ø—Ü–∏—è –≤–∞–∂–Ω–∞ —á–µ—Ä–µ–∑ –≤—Ö–æ–¥—è—â–∏–µ —Å–≤—è–∑–∏ –æ—Ç –¥—Ä—É–≥–∏—Ö –≤–∞–∂–Ω—ã—Ö —É–∑–ª–æ–≤. –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –≤–∞–∂–Ω–µ–µ —Å–∏–ª—ã —Å–≤—è–∑–∏.";
                    } else if (!respectDirection && useWeightedPaths) {
                        return "–ù–µ–Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–π –≤–∑–≤–µ—à–µ–Ω–Ω—ã–π: –∫–æ–Ω—Ü–µ–ø—Ü–∏—è –≤–∞–∂–Ω–∞ —á–µ—Ä–µ–∑ —Å–∏–ª—å–Ω—ã–µ —Å–≤—è–∑–∏ —Å –¥—Ä—É–≥–∏–º–∏ –≤–∞–∂–Ω—ã–º–∏ –∫–æ–Ω—Ü–µ–ø—Ü–∏—è–º–∏. –í–∑–∞–∏–º–Ω–æ–µ —É—Å–∏–ª–µ–Ω–∏–µ —á–µ—Ä–µ–∑ —Ñ—É–Ω–¥–∞–º–µ–Ω—Ç–∞–ª—å–Ω—ã–µ –≤–ª–∏—è–Ω–∏—è.";
                    } else {
                        return "–ù–µ–Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–π: –∫–æ–Ω—Ü–µ–ø—Ü–∏—è –≤–∞–∂–Ω–∞, –µ—Å–ª–∏ —Å–≤—è–∑–∞–Ω–∞ —Å –¥—Ä—É–≥–∏–º–∏ –≤–∞–∂–Ω—ã–º–∏ –∫–æ–Ω—Ü–µ–ø—Ü–∏—è–º–∏. –°–∏–º–º–µ—Ç—Ä–∏—á–Ω–æ–µ –≤–∑–∞–∏–º–Ω–æ–µ —É—Å–∏–ª–µ–Ω–∏–µ, –≤—Å–µ —Å–≤—è–∑–∏ —Ä–∞–≤–Ω—ã.";
                    }
                },
                usage: "–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –¥–ª—è –≤—ã—è–≤–ª–µ–Ω–∏—è –∫–æ–Ω—Ü–µ–ø—Ü–∏–π, –∫–æ—Ç–æ—Ä—ã–µ —Å–æ—Å—Ç–∞–≤–ª—è—é—Ç —è–¥—Ä–æ —Ñ–∏–ª–æ—Å–æ—Ñ—Å–∫–æ–π —Ç—Ä–∞–¥–∏—Ü–∏–∏. –û–Ω–∏ –≤–∞–∂–Ω—ã –Ω–µ —Å–∞–º–∏ –ø–æ —Å–µ–±–µ, –∞ —á–µ—Ä–µ–∑ –≤–∑–∞–∏–º–Ω–æ–µ —É—Å–∏–ª–µ–Ω–∏–µ —Å –¥—Ä—É–≥–∏–º–∏ –∫–ª—é—á–µ–≤—ã–º–∏ –∏–¥–µ—è–º–∏.",
                formula: () => {
                    const base = "x(v) = (1/Œª) √ó Œ£ A(v,u) √ó x(u)";
                    return base + (useWeightedPaths ? ", A ‚Äî –≤–∑–≤–µ—à–µ–Ω–Ω–∞—è –º–∞—Ç—Ä–∏—Ü–∞" : ", A ‚Äî –±–∏–Ω–∞—Ä–Ω–∞—è –º–∞—Ç—Ä–∏—Ü–∞");
                }
            }
        };
        
        // –§—É–Ω–∫—Ü–∏—è –ø–æ–∫–∞–∑–∞ –æ–ø–∏—Å–∞–Ω–∏—è –º–µ—Ç—Ä–∏–∫–∏
        function showMetricDescription(metricName) {
            const desc = metricDescriptions[metricName];
            if (!desc) return '';
            
            // –ü–æ–ª—É—á–∞–µ–º –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏–µ –∑–Ω–∞—á–µ–Ω–∏—è (—Ñ—É–Ω–∫—Ü–∏–∏ –∏–ª–∏ —Å—Ç–∞—Ç–∏—á–µ—Å–∫–∏–µ —Å—Ç—Ä–æ–∫–∏)
            const interpretation = typeof desc.interpretation === 'function' 
                ? desc.interpretation() 
                : desc.interpretation;
            const formula = typeof desc.formula === 'function' 
                ? desc.formula() 
                : desc.formula;
            
            return `
                <div style="background: rgba(52, 152, 219, 0.1); padding: 12px; border-radius: 8px; margin-bottom: 12px; font-size: 11px; line-height: 1.6;">
                    <div style="font-weight: 700; color: #2c3e50; margin-bottom: 6px; font-size: 12px;">
                        ${desc.name}
                    </div>
                    <div style="color: #34495e; margin-bottom: 8px;">
                        <strong>–ß—Ç–æ –∏–∑–º–µ—Ä—è–µ—Ç:</strong> ${desc.description}
                    </div>
                    <div style="color: #34495e; margin-bottom: 8px;">
                        <strong>–ò–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∞—Ü–∏—è:</strong> ${interpretation}
                    </div>
                    <div style="color: #34495e; margin-bottom: 8px;">
                        <strong>–ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ:</strong> ${desc.usage}
                    </div>
                    <div style="color: #7f8c8d; font-style: italic; font-size: 10px;">
                        <strong>–§–æ—Ä–º—É–ª–∞:</strong> ${formula}
                    </div>
                </div>
            `;
        }
        
        // –§—É–Ω–∫—Ü–∏—è –ø–æ–∫–∞–∑–∞ –æ–ø–∏—Å–∞–Ω–∏—è –º–µ—Ç—Ä–∏–∫–∏
        function showMetricDescription(metricName) {
            const desc = metricDescriptions[metricName];
            if (!desc) return '';
            
            return `
                <div style="background: rgba(52, 152, 219, 0.1); padding: 12px; border-radius: 8px; margin-bottom: 12px; font-size: 11px; line-height: 1.6;">
                    <div style="font-weight: 700; color: #2c3e50; margin-bottom: 6px; font-size: 12px;">
                        ${desc.name}
                    </div>
                    <div style="color: #34495e; margin-bottom: 8px;">
                        <strong>–ß—Ç–æ –∏–∑–º–µ—Ä—è–µ—Ç:</strong> ${desc.description}
                    </div>
                    <div style="color: #34495e; margin-bottom: 8px;">
                        <strong>–ò–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∞—Ü–∏—è:</strong> ${desc.interpretation}
                    </div>
                    <div style="color: #34495e; margin-bottom: 8px;">
                        <strong>–ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ:</strong> ${desc.usage}
                    </div>
                    <div style="color: #7f8c8d; font-style: italic; font-size: 10px;">
                        <strong>–§–æ—Ä–º—É–ª–∞:</strong> ${desc.formula}
                    </div>
                </div>
            `;
        }
        
        // –¢–µ–∫—É—â–∞—è –≤—ã–±—Ä–∞–Ω–Ω–∞—è –º–µ—Ç—Ä–∏–∫–∞
        let currentMetric = null;
        
        // –ü–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è –≤–µ—Å–æ–≤
        function toggleWeightUsage() {
            useWeightedPaths = document.getElementById('useWeightsToggle').checked;
            
            // –°–±—Ä–∞—Å—ã–≤–∞–µ–º –∫—ç—à –≤—Å–µ—Ö –º–µ—Ç—Ä–∏–∫, –∑–∞–≤–∏—Å—è—â–∏—Ö –æ—Ç –≤–µ—Å–æ–≤
            invalidateBetweennessCache();
            invalidatePageRankCache();
            invalidateClosenessCache();
            invalidateClusteringCache();
            invalidateEigenvectorCache();
            
            console.log('–†–µ–∂–∏–º —É—á—ë—Ç–∞ –≤–µ—Å–æ–≤:', useWeightedPaths ? '–í–∫–ª—é—á—ë–Ω' : '–í—ã–∫–ª—é—á–µ–Ω');
            
            // –ï—Å–ª–∏ –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è –∞–∫—Ç–∏–≤–Ω–∞, —Å–±—Ä–∞—Å—ã–≤–∞–µ–º –µ—ë
            if (isVisualizingBySize) {
                resetNodeSizes();
            }
            
            // –ï—Å–ª–∏ –µ—Å—Ç—å —Ç–µ–∫—É—â–∞—è –º–µ—Ç—Ä–∏–∫–∞, –æ–±–Ω–æ–≤–ª—è–µ–º –µ—ë
            if (currentMetric) {
                showMetric(currentMetric);
            }
        }
        
        // –ü–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ —É—á—ë—Ç–∞ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–Ω–æ—Å—Ç–∏ (–ù–û–í–û–ï!)
        function toggleDirectionUsage() {
            respectDirection = document.getElementById('respectDirectionToggle').checked;
            
            // –°–±—Ä–∞—Å—ã–≤–∞–µ–º –∫—ç—à –í–°–ï–• –º–µ—Ç—Ä–∏–∫, —Ç–∞–∫ –∫–∞–∫ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–Ω–æ—Å—Ç—å –≤–ª–∏—è–µ—Ç –Ω–∞ –≤—Å—ë
            invalidateInfluenceCache();
            invalidateBetweennessCache();
            invalidatePageRankCache();
            invalidateClosenessCache();
            invalidateClusteringCache(); // –ö–ª–∞—Å—Ç–µ—Ä–∏–∑–∞—Ü–∏—è –Ω–µ –∑–∞–≤–∏—Å–∏—Ç, –Ω–æ —Å–±—Ä–æ—Å–∏–º –¥–ª—è –µ–¥–∏–Ω–æ–æ–±—Ä–∞–∑–∏—è
            invalidateEigenvectorCache();
            
            console.log('–†–µ–∂–∏–º —É—á—ë—Ç–∞ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–Ω–æ—Å—Ç–∏:', respectDirection ? '–í–∫–ª—é—á—ë–Ω' : '–í—ã–∫–ª—é—á–µ–Ω');
            
            // –ï—Å–ª–∏ –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è –∞–∫—Ç–∏–≤–Ω–∞, —Å–±—Ä–∞—Å—ã–≤–∞–µ–º –µ—ë
            if (isVisualizingBySize) {
                resetNodeSizes();
            }
            
            // –ï—Å–ª–∏ –µ—Å—Ç—å —Ç–µ–∫—É—â–∞—è –º–µ—Ç—Ä–∏–∫–∞, –æ–±–Ω–æ–≤–ª—è–µ–º –µ—ë
            if (currentMetric) {
                showMetric(currentMetric);
            }
        }
        
        // –ë—ã—Å—Ç—Ä—ã–π –∞–Ω–∞–ª–∏–∑ (—Ç–æ–ª—å–∫–æ Degree –∏ –æ–±—â–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞)
        async function runQuickAnalysis() {
            showProgress('–ë—ã—Å—Ç—Ä—ã–π –∞–Ω–∞–ª–∏–∑...', 0);
            
            try {
                // –û–±—â–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
                const stats = await calculateGraphStatistics((current, total) => {
                    const percent = Math.round((current / total) * 50);
                    showProgress('–û–±—â–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞...', percent);
                });
                displayGeneralStats(stats);
                
                // Degree centrality
                showProgress('–°—Ç–µ–ø–µ–Ω—å —É–∑–ª–æ–≤...', 75);
                await new Promise(resolve => setTimeout(resolve, 100));
                
                document.getElementById('generalStatsSection').style.display = 'block';
                document.getElementById('metricsSection').style.display = 'block';
                document.getElementById('visualizationSection').style.display = 'block';
                
                switchMetric('degree');
                
                showProgress('–ì–æ—Ç–æ–≤–æ!', 100);
                setTimeout(hideProgress, 1000);
                
            } catch (error) {
                console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –∞–Ω–∞–ª–∏–∑–µ:', error);
                hideProgress();
                alert('–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –∞–Ω–∞–ª–∏–∑–µ');
            }
        }
        
        // –ü–æ–ª–Ω—ã–π –∞–Ω–∞–ª–∏–∑ (–≤—Å–µ –º–µ—Ç—Ä–∏–∫–∏)
        async function runFullAnalysis() {
            showProgress('–ó–∞–ø—É—Å–∫ –ø–æ–ª–Ω–æ–≥–æ –∞–Ω–∞–ª–∏–∑–∞...', 0);
            
            try {
                // 1. –û–±—â–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ (15%)
                const stats = await calculateGraphStatistics((current, total) => {
                    const percent = Math.round((current / total) * 15);
                    showProgress('–û–±—â–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞...', percent);
                });
                displayGeneralStats(stats);
                
                // 2. PageRank (15%)
                showProgress('–†–∞—Å—á—ë—Ç PageRank...', 15);
                await calculatePageRank(20, 0.85, (current, total) => {
                    const percent = 15 + Math.round((current / total) * 15);
                    showProgress('–†–∞—Å—á—ë—Ç PageRank...', percent);
                });
                
                // 3. Eigenvector (15%)
                showProgress('–†–∞—Å—á—ë—Ç Eigenvector...', 30);
                await calculateEigenvectorCentrality(100, (current, total) => {
                    const percent = 30 + Math.round((current / total) * 15);
                    showProgress('–†–∞—Å—á—ë—Ç Eigenvector...', percent);
                });
                
                // 4. Betweenness (25%)
                showProgress('–†–∞—Å—á—ë—Ç Betweenness...', 45);
                await calculateBetweennessAsync((current, total) => {
                    const percent = 45 + Math.round((current / total) * 25);
                    showProgress('–†–∞—Å—á—ë—Ç Betweenness...', percent);
                });
                
                // 5. Closeness (20%)
                showProgress('–†–∞—Å—á—ë—Ç Closeness...', 70);
                await calculateClosenessCentrality((current, total) => {
                    const percent = 70 + Math.round((current / total) * 20);
                    showProgress('–†–∞—Å—á—ë—Ç Closeness...', percent);
                });
                
                // 6. Clustering (10%)
                showProgress('–†–∞—Å—á—ë—Ç Clustering...', 90);
                await new Promise(resolve => setTimeout(resolve, 100));
                calculateClusteringCoefficient();
                
                document.getElementById('generalStatsSection').style.display = 'block';
                document.getElementById('metricsSection').style.display = 'block';
                document.getElementById('visualizationSection').style.display = 'block';
                
                switchMetric('pagerank');
                
                showProgress('–ê–Ω–∞–ª–∏–∑ –∑–∞–≤–µ—Ä—à—ë–Ω!', 100);
                setTimeout(hideProgress, 1500);
                
                console.log('–ü–æ–ª–Ω—ã–π –∞–Ω–∞–ª–∏–∑ –∑–∞–≤–µ—Ä—à—ë–Ω');
                
            } catch (error) {
                console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª–Ω–æ–º –∞–Ω–∞–ª–∏–∑–µ:', error);
                hideProgress();
                alert('–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ –∞–Ω–∞–ª–∏–∑–µ');
            }
        }
        
        // –ü–æ–∫–∞–∑–∞—Ç—å –ø—Ä–æ–≥—Ä–µ—Å—Å
        function showProgress(label, percent) {
            const progressDiv = document.getElementById('analysisProgress');
            const progressBar = document.getElementById('progressBar');
            const progressPercent = document.getElementById('progressPercent');
            const progressLabel = document.getElementById('progressLabel');
            
            progressDiv.style.display = 'block';
            progressBar.style.width = percent + '%';
            progressPercent.textContent = percent + '%';
            progressLabel.textContent = label;
        }
        
        // –°–∫—Ä—ã—Ç—å –ø—Ä–æ–≥—Ä–µ—Å—Å
        function hideProgress() {
            const progressDiv = document.getElementById('analysisProgress');
            progressDiv.style.display = 'none';
        }
        
        // –°–±—Ä–æ—Å –≤—Å–µ–≥–æ –∫—ç—à–∞
        function clearAllCache() {
            invalidateInfluenceCache();
            invalidateBetweennessCache();
            invalidatePageRankCache();
            invalidateClosenessCache();
            invalidateClusteringCache();
            invalidateEigenvectorCache();
            
            // –°–±—Ä–æ—Å–∏—Ç—å –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—é
            if (isVisualizingBySize) {
                resetNodeSizes();
            }
            
            document.getElementById('generalStatsSection').style.display = 'none';
            document.getElementById('metricsSection').style.display = 'none';
            document.getElementById('visualizationSection').style.display = 'none';
            
            currentMetric = null;
            
            console.log('–í–µ—Å—å –∫—ç—à –æ—á–∏—â–µ–Ω');
            alert('–ö—ç—à –æ—á–∏—â–µ–Ω. –ó–∞–ø—É—Å—Ç–∏—Ç–µ –∞–Ω–∞–ª–∏–∑ —Å–Ω–æ–≤–∞.');
        }
        
        // –û—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ –æ–±—â–µ–π —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏
        function displayGeneralStats(stats) {
            const statsDiv = document.getElementById('generalStats');
            
            const modeInfo = `
                <div style="background: rgba(52, 152, 219, 0.08); padding: 8px; border-radius: 5px; margin-bottom: 8px; font-size: 10px;">
                    –†–µ–∂–∏–º: <strong>${respectDirection ? '–ù–∞–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–π' : '–ù–µ–Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã–π'}</strong> –≥—Ä–∞—Ñ, 
                    –≤–µ—Å–∞ <strong>${useWeightedPaths ? '—É—á–∏—Ç—ã–≤–∞—é—Ç—Å—è' : '–Ω–µ —É—á–∏—Ç—ã–≤–∞—é—Ç—Å—è'}</strong>
                </div>
            `;
            
            statsDiv.innerHTML = modeInfo + `
                –£–∑–ª–æ–≤: <strong>${stats.nodes}</strong><br>
                –†—ë–±–µ—Ä: <strong>${stats.edges}</strong><br>
                –ü–ª–æ—Ç–Ω–æ—Å—Ç—å: <strong>${stats.density.toFixed(4)}</strong><br>
                –°—Ä–µ–¥–Ω—è—è —Å—Ç–µ–ø–µ–Ω—å: <strong>${stats.avgDegree.toFixed(2)}</strong><br>
                –í–∑–∞–∏–º–Ω–æ—Å—Ç—å: <strong>${(stats.reciprocity * 100).toFixed(1)}%</strong><br>
                –î–∏–∞–º–µ—Ç—Ä: <strong>${stats.diameter}</strong><br>
                –°—Ä–µ–¥–Ω–∏–π –ø—É—Ç—å: <strong>${stats.avgPathLength.toFixed(2)}</strong><br>
                –ö–æ–º–ø–æ–Ω–µ–Ω—Ç —Å–≤—è–∑–Ω–æ—Å—Ç–∏: <strong>${stats.components}</strong><br>
                –°—Ä–µ–¥–Ω—è—è –∫–ª–∞—Å—Ç–µ—Ä–∏–∑–∞—Ü–∏—è: <strong>${stats.avgClustering.toFixed(3)}</strong>
            `;
        }
        
        // –ü–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ –º–µ—Ç—Ä–∏–∫
        function switchMetric(metricName) {
            currentMetric = metricName;
            
            // –û–±–Ω–æ–≤–ª—è–µ–º –∞–∫—Ç–∏–≤–Ω—É—é –∫–Ω–æ–ø–∫—É
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            document.querySelector(`[data-metric="${metricName}"]`)?.classList.add('active');
            
            showMetric(metricName);
        }
        
        // –ü–æ–∫–∞–∑–∞—Ç—å –∫–æ–Ω–∫—Ä–µ—Ç–Ω—É—é –º–µ—Ç—Ä–∏–∫—É
        function showMetric(metricName) {
            const contentDiv = document.getElementById('metricContent');
            
            // –ü–æ–∫–∞–∑–∞—Ç—å –æ–ø–∏—Å–∞–Ω–∏–µ –º–µ—Ç—Ä–∏–∫–∏
            let html = showMetricDescription(metricName);
            
            switch(metricName) {
                case 'degree':
                    const degree = calculateWeightedDegree();
                    html += formatMetricResults(
                        degree.slice(0, 10), 
                        'totalWeight',
                        useWeightedPaths ? '–í–∑–≤–µ—à–µ–Ω–Ω–∞—è —Å—Ç–µ–ø–µ–Ω—å' : '–°—Ç–µ–ø–µ–Ω—å —É–∑–ª–∞'
                    );
                    break;
                    
                case 'pagerank':
                    if (pageRankCache) {
                        html += formatMetricResults(
                            pageRankCache.slice(0, 10), 
                            'value',
                            'PageRank',
                            true
                        );
                    } else {
                        html += '<div style="font-size: 11px; color: #95a5a6; padding: 10px;">–ó–∞–ø—É—Å—Ç–∏—Ç–µ –∞–Ω–∞–ª–∏–∑ –¥–ª—è –≤—ã—á–∏—Å–ª–µ–Ω–∏—è PageRank</div>';
                    }
                    break;
                    
                case 'betweenness':
                    if (betweennessCache) {
                        html += formatMetricResults(
                            betweennessCache.slice(0, 10), 
                            'value',
                            'Betweenness',
                            true
                        );
                    } else {
                        html += '<div style="font-size: 11px; color: #95a5a6; padding: 10px;">–ó–∞–ø—É—Å—Ç–∏—Ç–µ –∞–Ω–∞–ª–∏–∑ –¥–ª—è –≤—ã—á–∏—Å–ª–µ–Ω–∏—è Betweenness</div>';
                    }
                    break;
                    
                case 'closeness':
                    if (closenessCache) {
                        html += formatMetricResults(
                            closenessCache.slice(0, 10), 
                            'value',
                            'Closeness',
                            true
                        );
                    } else {
                        html += '<div style="font-size: 11px; color: #95a5a6; padding: 10px;">–ó–∞–ø—É—Å—Ç–∏—Ç–µ –∞–Ω–∞–ª–∏–∑ –¥–ª—è –≤—ã—á–∏—Å–ª–µ–Ω–∏—è Closeness</div>';
                    }
                    break;
                    
                case 'clustering':
                    if (clusteringCache) {
                        html += formatMetricResults(
                            clusteringCache.slice(0, 10), 
                            'value',
                            '–ö–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç –∫–ª–∞—Å—Ç–µ—Ä–∏–∑–∞—Ü–∏–∏',
                            true
                        );
                    } else {
                        const clustering = calculateClusteringCoefficient();
                        html += formatMetricResults(
                            clustering.slice(0, 10), 
                            'value',
                            '–ö–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç –∫–ª–∞—Å—Ç–µ—Ä–∏–∑–∞—Ü–∏–∏',
                            true
                        );
                    }
                    break;
                    
                case 'eigenvector':
                    if (eigenvectorCache) {
                        html += formatMetricResults(
                            eigenvectorCache.slice(0, 10), 
                            'value',
                            'Eigenvector Centrality',
                            true
                        );
                    } else {
                        html += '<div style="font-size: 11px; color: #95a5a6; padding: 10px;">–ó–∞–ø—É—Å—Ç–∏—Ç–µ –∞–Ω–∞–ª–∏–∑ –¥–ª—è –≤—ã—á–∏—Å–ª–µ–Ω–∏—è Eigenvector</div>';
                    }
                    break;
            }
            
            contentDiv.innerHTML = html;
        }
        
        // –§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –º–µ—Ç—Ä–∏–∫–∏
        function formatMetricResults(data, valueKey, title, isDecimal = false) {
            if (!data || data.length === 0) {
                return '<div style="font-size: 11px; color: #95a5a6; padding: 10px;">–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö</div>';
            }
            
            let html = `<h4 style="margin: 10px 0; font-size: 13px;">${title}</h4>`;
            
            data.forEach((item, index) => {
                const value = item[valueKey];
                const displayValue = isDecimal ? value.toFixed(4) : Math.round(value);
                
                html += `
                    <div class="stat-item" onclick="highlightNodeById('${item.node.id}')">
                        <span class="stat-rank">${index + 1}.</span>
                        <span class="stat-name">${item.node.label}</span>
                        <span class="stat-value">${displayValue}</span>
                        <span class="stat-philosopher">${item.node.concept}</span>
                    </div>
                `;
            });
            
            return html;
        }
        
        // –ü–æ–¥—Å–≤–µ—Ç–∫–∞ —É–∑–ª–∞ –ø–æ ID
        function highlightNodeById(nodeId) {
            const nodeData = nodes.find(n => n.id === nodeId);
            if (nodeData) {
                selectedNodes.clear();
                selectedNodes.add(nodeData);
                highlightConnected([nodeData]);
                
                // –¶–µ–Ω—Ç—Ä–∏—Ä—É–µ–º –Ω–∞ —É–∑–ª–µ
                const nodeElement = node.filter(d => d.id === nodeId);
                if (nodeElement.size() > 0) {
                    const d = nodeElement.datum();
                    const transform = d3.zoomIdentity
                        .translate(width / 2 - d.x, height / 2 - d.y)
                        .scale(1.5);
                    svg.transition().duration(750).call(zoom.transform, transform);
                }
            }
        }
        
        // –≠–∫—Å–ø–æ—Ä—Ç –≤ PNG
        function exportToPNG() {
            const svgElement = document.getElementById('graph');
            const svgClone = svgElement.cloneNode(true);
            
            // –ü–æ–ª—É—á–∞–µ–º —Ç–µ–∫—É—â–∏–π transform –æ—Ç zoom
            const gElement = svgClone.querySelector('g');
            const transform = g.attr('transform');
            if (transform) {
                gElement.setAttribute('transform', transform);
            }
            
            // –ü—Ä–∏–º–µ–Ω—è–µ–º –∏–Ω–ª–∞–π–Ω-—Å—Ç–∏–ª–∏ –∫ —Ç–µ–∫—Å—Ç—É
            const textElements = svgClone.querySelectorAll('text');
            textElements.forEach(text => {
                text.style.fontFamily = "'Segoe UI', Tahoma, Geneva, Verdana, sans-serif";
                text.style.fontSize = '10px';
                text.style.fontWeight = '600';
                text.style.fill = '#fff';
                text.style.textShadow = '0 0 4px black';
            });
            
            // –ü—Ä–∏–º–µ–Ω—è–µ–º –∏–Ω–ª–∞–π–Ω-—Å—Ç–∏–ª–∏ –∫ —É–∑–ª–∞–º
            const circles = svgClone.querySelectorAll('circle');
            circles.forEach(circle => {
                const computedStyle = window.getComputedStyle(circle);
                circle.style.strokeWidth = '3px';
                circle.style.filter = 'drop-shadow(0 0 10px rgba(255,255,255,0.4))';
            });
            
            // –ü—Ä–∏–º–µ–Ω—è–µ–º –∏–Ω–ª–∞–π–Ω-—Å—Ç–∏–ª–∏ –∫ —Å–≤—è–∑—è–º
            const paths = svgClone.querySelectorAll('path.link');
            paths.forEach(path => {
                path.style.fill = 'none';
                const computedStyle = window.getComputedStyle(path);
                path.style.stroke = computedStyle.stroke;
                path.style.strokeWidth = computedStyle.strokeWidth;
                path.style.opacity = computedStyle.opacity;
            });
            
            // –£–≤–µ–ª–∏—á–∏–≤–∞–µ–º —Ä–∞–∑—Ä–µ—à–µ–Ω–∏–µ –¥–ª—è –ª—É—á—à–µ–≥–æ –∫–∞—á–µ—Å—Ç–≤–∞
            const scale = 2;
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            canvas.width = width * scale;
            canvas.height = height * scale;
            ctx.scale(scale, scale);
            
            const svgData = new XMLSerializer().serializeToString(svgClone);
            const img = new Image();
            
            img.onload = function() {
                // –†–∏—Å—É–µ–º —Ñ–æ–Ω
                ctx.fillStyle = '#0f0c29';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // –†–∏—Å—É–µ–º SVG
                ctx.drawImage(img, 0, 0, width, height);
                
                // –ö–æ–Ω–≤–µ—Ä—Ç–∏—Ä—É–µ–º –≤ PNG
                canvas.toBlob(function(blob) {
                    const url = URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    link.download = 'philosophy-graph.png';
                    link.href = url;
                    link.click();
                    URL.revokeObjectURL(url);
                }, 'image/png');
            };
            
            img.onerror = function(e) {
                console.error('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è:', e);
                alert('–û—à–∏–±–∫–∞ –ø—Ä–∏ —ç–∫—Å–ø–æ—Ä—Ç–µ. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —ç–∫—Å–ø–æ—Ä—Ç –≤ SVG.');
            };
            
            // –ö–æ–¥–∏—Ä—É–µ–º SVG –¥–∞–Ω–Ω—ã–µ
            const svgBlob = new Blob([svgData], { type: 'image/svg+xml;charset=utf-8' });
            const url = URL.createObjectURL(svgBlob);
            img.src = url;
        }
        
        // –≠–∫—Å–ø–æ—Ä—Ç –≤ SVG
        function exportToSVG() {
            const svgElement = document.getElementById('graph');
            const svgData = new XMLSerializer().serializeToString(svgElement);
            
            const blob = new Blob([svgData], { type: 'image/svg+xml;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            
            const link = document.createElement('a');
            link.download = 'philosophy-graph.svg';
            link.href = url;
            link.click();
            
            URL.revokeObjectURL(url);
        }

        const width = window.innerWidth;
        const height = window.innerHeight;
        
        const svg = d3.select("#graph")
            .attr("width", width)
            .attr("height", height);

        // –ö–æ–Ω—Ç–µ–π–Ω–µ—Ä –¥–ª—è –º–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏—è –∏ –ø—Ä–æ–∫—Ä—É—Ç–∫–∏
        const g = svg.append("g");

        // –ù–∞—Å—Ç—Ä–æ–π–∫–∞ zoom
        const zoom = d3.zoom()
            .scaleExtent([0.1, 4])
            .on("zoom", (event) => {
                g.attr("transform", event.transform);
            });

        svg.call(zoom);

        // –ö–ª–∏–∫ –Ω–∞ —Ñ–æ–Ω –¥–ª—è —Å–±—Ä–æ—Å–∞ –ø–æ–¥—Å–≤–µ—Ç–∫–∏
        svg.on("click", function(event) {
            if (event.target === this) {
                resetHighlight();
            }
        });

        const defs = svg.append("defs");
        
        Object.keys(relationTypesObj).forEach(type => {
            defs.append("marker")
                .attr("id", `arrow-${type}`)
                .attr("viewBox", "0 -5 10 10")
                .attr("refX", 26)
                .attr("refY", 0)
                .attr("markerWidth", 6)
                .attr("markerHeight", 6)
                .attr("orient", "auto")
                .append("path")
                .attr("d", "M0,-5L10,0L0,5")
                .attr("fill", relationTypesObj[type].color);
            // –°–ø–µ—Ü–∏–∞–ª—å–Ω—ã–π –º–∞—Ä–∫–µ—Ä –¥–ª—è –≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏—Ö –ø—Ä–æ—Ç–∏–≤–æ—Ä–µ—á–∏–π
            defs.append("marker")
                .attr("id", "arrow-internal_contradiction")
                .attr("viewBox", "0 -5 10 10")
                .attr("refX", 26)
                .attr("refY", 0)
                .attr("markerWidth", 6)
                .attr("markerHeight", 6)
                .attr("orient", "auto")
                .append("path")
                .attr("d", "M0,-5L10,0L0,5")
                .attr("fill", relationTypesObj["internal_contradiction"].color);
            
        });

        let simulation = d3.forceSimulation(nodes)
            .force("link", d3.forceLink(links).id(d => d.id).distance(160))
            .force("charge", d3.forceManyBody().strength(-350))
            .force("center", d3.forceCenter(width / 2, height / 2))
            .force("collision", d3.forceCollide().radius(45))
            .alphaDecay(0.02); // –£—Å–∫–æ—Ä—è–µ–º –∑–∞—Ç—É—Ö–∞–Ω–∏–µ —Å–∏–º—É–ª—è—Ü–∏–∏
        
        // –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Å–∏–º—É–ª—è—Ü–∏—é –ø–æ—Å–ª–µ —Å—Ç–∞–±–∏–ª–∏–∑–∞—Ü–∏–∏
        let tickCount = 0;
        const maxTicks = 300; // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ç–∏–∫–æ–≤
        
        simulation.on("tick", () => {
            tickCount++;
            
            // –û–ø—Ç–∏–º–∏–∑–∞—Ü–∏—è: –æ–±–Ω–æ–≤–ª—è–µ–º —Ç–æ–ª—å–∫–æ –≤–∏–¥–∏–º—ã–µ —ç–ª–µ–º–µ–Ω—Ç—ã
            link.filter(function() { return this.style.display !== "none"; })
                .attr("d", d => {
                    const dx = d.target.x - d.source.x;
                    const dy = d.target.y - d.source.y;
                    const dr = Math.sqrt(dx * dx + dy * dy) * 1.5;
                    return `M${d.source.x},${d.source.y}A${dr},${dr} 0 0,1 ${d.target.x},${d.target.y}`;
                });

            node.filter(function() { return this.style.display !== "none"; })
                .attr("transform", d => `translate(${d.x},${d.y})`);
            
            // –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –ø–æ—Å–ª–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω–æ–≥–æ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ —Ç–∏–∫–æ–≤
            if (tickCount >= maxTicks) {
                simulation.stop();
            }
        });
        
        simulation.on("end", () => {
            console.log("–°–∏–º—É–ª—è—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞ –ø–æ—Å–ª–µ", tickCount, "—Ç–∏–∫–æ–≤");
            console.log("–ü—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å - —É–∑–ª–æ–≤:", nodes.length, "—Å–≤—è–∑–µ–π:", links.length);
            
            // –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –ø–∞–º—è—Ç–∏ (–µ—Å–ª–∏ –¥–æ—Å—Ç—É–ø–Ω–æ)
            if (performance.memory) {
                console.log("–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –ø–∞–º—è—Ç–∏:", 
                    Math.round(performance.memory.usedJSHeapSize / 1048576), "–ú–ë");
            }
        });

        // –ü–æ–∑–∏—Ü–∏–∏ –¥–ª—è –≥—Ä—É–ø–ø–∏—Ä–æ–≤–∫–∏ –ø–æ —Ñ–∏–ª–æ—Å–æ—Ñ–∞–º
        const philosopherNames = Object.keys(philosopherConcepts);
        const groupPositions = {};
        const cols = 6;
        const rows = Math.ceil(philosopherNames.length / cols);
        const spacingX = width / (cols + 1);
        const spacingY = height / (rows + 1);

        philosopherNames.forEach((phil, i) => {
            const col = i % cols;
            const row = Math.floor(i / cols);
            groupPositions[phil] = {
                x: spacingX * (col + 1),
                y: spacingY * (row + 1)
            };
        });

        let isGrouped = false;
        let selectedNodes = new Set(); // –ú–Ω–æ–∂–µ—Å—Ç–≤–æ –≤—ã–±—Ä–∞–Ω–Ω—ã—Ö —É–∑–ª–æ–≤

        const link = g.append("g")
            .selectAll("path")
            .data(links)
            .enter()
            .append("path")
            .attr("class", d => {
                let classes = "link";
                if (d.bidirectional) classes += " bidirectional";
                if (d.type === "internal_contradiction") classes += " internal-contradiction";
                
                // –î–æ–±–∞–≤–ª—è–µ–º –∫–ª–∞—Å—Å –≤–µ—Å–∞
                if (d.weight === 1) classes += " weight-weak";
                else if (d.weight === 2) classes += " weight-medium";
                else if (d.weight === 3) classes += " weight-strong";
                
                return classes;
            })
            .attr("stroke", d => relationTypesObj[d.type].color)
            .attr("marker-end", d => `url(#arrow-${d.type})`);

        const node = g.append("g")
            .selectAll("g")
            .data(nodes)
            .enter()
            .append("g")
            .attr("class", "node")
            .call(d3.drag()
                .on("start", dragstarted)
                .on("drag", dragged)
                .on("end", dragended));

        node.append("circle")
            .attr("r", 18)
            .attr("fill", d => philosopherConcepts[d.concept].color)
            .attr("stroke", "#fff");

        node.append("text")
            .attr("dy", -25)
            .attr("text-anchor", "middle")
            .text(d => d.label);

        // –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–ª–∏–∫–∞ –Ω–∞ —É–∑–ª–µ —Å –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏–µ–º —É—Ç–µ—á–∫–∏ —Ç–∞–π–º–µ—Ä–∞
        let clickTimer = null;
        let clickCount = 0;
        let lastClickedNode = null;
        
        node.on("click", function(event, d) {
            event.stopPropagation();
            
            clickCount++;
            
            // –û—á–∏—â–∞–µ–º –ø—Ä–µ–¥—ã–¥—É—â–∏–π —Ç–∞–π–º–µ—Ä –ø—Ä–∏ –Ω–æ–≤–æ–º –∫–ª–∏–∫–µ
            if (clickTimer) {
                clearTimeout(clickTimer);
                clickTimer = null;
            }
            
            if (clickCount === 1) {
                lastClickedNode = d;
                // –ü–µ—Ä–≤—ã–π –∫–ª–∏–∫ - –∂–¥—ë–º, –±—É–¥–µ—Ç –ª–∏ –≤—Ç–æ—Ä–æ–π
                clickTimer = setTimeout(() => {
                    // –û–¥–∏–Ω–∞—Ä–Ω—ã–π –∫–ª–∏–∫ - –ø–æ–¥—Å–≤–µ—Ç–∫–∞ —Å–≤—è–∑–µ–π
                    if (event.ctrlKey || event.metaKey) {
                        // Ctrl –∑–∞–∂–∞—Ç - –º–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã–π –≤—ã–±–æ—Ä
                        if (selectedNodes.has(lastClickedNode)) {
                            selectedNodes.delete(lastClickedNode);
                        } else {
                            selectedNodes.add(lastClickedNode);
                        }
                    } else {
                        // Ctrl –Ω–µ –∑–∞–∂–∞—Ç - –æ–¥–∏–Ω–æ—á–Ω—ã–π –≤—ã–±–æ—Ä
                        if (selectedNodes.size === 1 && selectedNodes.has(lastClickedNode)) {
                            selectedNodes.clear();
                        } else {
                            selectedNodes.clear();
                            selectedNodes.add(lastClickedNode);
                        }
                    }
                    
                    if (selectedNodes.size > 0) {
                        highlightConnected(Array.from(selectedNodes));
                    } else {
                        resetHighlight();
                    }
                    clickCount = 0;
                    clickTimer = null;
                    lastClickedNode = null;
                }, 300);
            } else if (clickCount === 2) {
                // –î–≤–æ–π–Ω–æ–π –∫–ª–∏–∫ - –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –¥–µ—Ç–∞–ª—å–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é
                showDetailModal(d);
                clickCount = 0;
                lastClickedNode = null;
            }
        });

        // –ü–æ–¥—Å–≤–µ—Ç–∫–∞ —Å–≤—è–∑–∞–Ω–Ω—ã—Ö —É–∑–ª–æ–≤ –∏ —Å–≤—è–∑–µ–π (–æ–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è)
        function highlightConnected(selectedDataArray) {
            const connectedNodes = new Set();
            const connectedLinks = new Set();
            
            // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –∫–∞–∂–¥—ã–π –≤—ã–±—Ä–∞–Ω–Ω—ã–π —É–∑–µ–ª
            selectedDataArray.forEach(selectedData => {
                connectedNodes.add(selectedData.id);
                
                // –ù–∞—Ö–æ–¥–∏–º –≤—Å–µ —Å–≤—è–∑–∞–Ω–Ω—ã–µ —É–∑–ª—ã –∏ —Å–≤—è–∑–∏
                links.forEach(l => {
                    const sourceId = l.source.id || l.source;
                    const targetId = l.target.id || l.target;
                    
                    if (sourceId === selectedData.id) {
                        connectedNodes.add(targetId);
                        connectedLinks.add(l);
                    } else if (targetId === selectedData.id) {
                        connectedNodes.add(sourceId);
                        connectedLinks.add(l);
                    }
                });
            });
            
            // –ü—Ä–∏–º–µ–Ω—è–µ–º —Å—Ç–∏–ª–∏ –ø–∞–∫–µ—Ç–Ω–æ –¥–ª—è –ª—É—á—à–µ–π –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
            const selectedIds = new Set(selectedDataArray.map(sd => sd.id));
            
            node.classed("dimmed", d => !connectedNodes.has(d.id))
                .classed("highlighted", d => connectedNodes.has(d.id))
                .classed("selected", d => selectedIds.has(d.id));
            
            link.classed("dimmed", l => !connectedLinks.has(l))
                .classed("highlighted", l => connectedLinks.has(l));
        }

        // –°–±—Ä–æ—Å –ø–æ–¥—Å–≤–µ—Ç–∫–∏
        function resetHighlight() {
            selectedNodes.clear();
            node.classed("dimmed", false)
                .classed("highlighted", false)
                .classed("selected", false);
            link.classed("dimmed", false)
                .classed("highlighted", false)
                .classed("path-highlight", false);
        }

        // –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Å–≤–æ—Ä–∞—á–∏–≤–∞–Ω–∏–µ–º –ø–∞–Ω–µ–ª–µ–π
        function togglePanel(panelId) {
            const panel = document.getElementById(panelId);
            const isCollapsed = panel.classList.contains('collapsed');
            
            if (isCollapsed) {
                panel.classList.remove('collapsed');
                // –ú–µ–Ω—è–µ–º –∏–∫–æ–Ω–∫—É –Ω–∞ –º–∏–Ω—É—Å
                const btn = panel.querySelector('.collapse-btn .expand-icon');
                btn.textContent = '‚àí';
                // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ
                localStorage.setItem(`${panelId}_collapsed`, 'false');
            } else {
                panel.classList.add('collapsed');
                // –ú–µ–Ω—è–µ–º –∏–∫–æ–Ω–∫—É –Ω–∞ –ø–ª—é—Å
                const btn = panel.querySelector('.collapse-btn .expand-icon');
                btn.textContent = '+';
                // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ
                localStorage.setItem(`${panelId}_collapsed`, 'true');
            }
        }
        
        // –í–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ —Å–æ—Å—Ç–æ—è–Ω–∏—è –ø–∞–Ω–µ–ª–µ–π –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ
        function restorePanelStates() {
            const panels = ['pathFinder', 'statsPanel'];
            
            panels.forEach(panelId => {
                const collapsed = localStorage.getItem(`${panelId}_collapsed`) === 'true';
                if (collapsed) {
                    const panel = document.getElementById(panelId);
                    panel.classList.add('collapsed');
                    const btn = panel.querySelector('.collapse-btn .expand-icon');
                    if (btn) btn.textContent = '+';
                }
            });
        }

        // Tooltip —Å –¥–µ–±–∞—É–Ω—Å–æ–º –¥–ª—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏
        const tooltip = d3.select("#tooltip");
        let tooltipTimeout = null;

        node.on("mouseover", function(event, d) {
            if (tooltipTimeout) clearTimeout(tooltipTimeout);
            
            tooltipTimeout = setTimeout(() => {
                tooltip
                    .style("opacity", 1)
                    .html(`<strong>${d.label}</strong><br/>${d.description}<br/><em>${d.concept}</em>`)
                    .style("left", (event.pageX + 15) + "px")
                    .style("top", (event.pageY - 15) + "px");
            }, 100); // –ù–µ–±–æ–ª—å—à–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞
        })
        .on("mouseout", function() {
            if (tooltipTimeout) {
                clearTimeout(tooltipTimeout);
                tooltipTimeout = null;
            }
            tooltip.style("opacity", 0);
        });

        link.on("mouseover", function(event, d) {
            if (tooltipTimeout) clearTimeout(tooltipTimeout);
            
            tooltipTimeout = setTimeout(() => {
                const sourceNode = nodes.find(n => n.id === (d.source.id || d.source));
                const targetNode = nodes.find(n => n.id === (d.target.id || d.target));
                const direction = d.bidirectional ? "‚Üî" : "‚Üí";
                tooltip
                    .style("opacity", 1)
                    .html(`<strong>${relationTypesObj[d.type].label}</strong><br/>${sourceNode.label} ${direction} ${targetNode.label}`)
                    .style("left", (event.pageX + 15) + "px")
                    .style("top", (event.pageY - 15) + "px");
            }, 100);
        })
        .on("mouseout", function() {
            if (tooltipTimeout) {
                clearTimeout(tooltipTimeout);
                tooltipTimeout = null;
            }
            tooltip.style("opacity", 0);
        });

        function dragstarted(event, d) {
            if (!event.active) {
                tickCount = 0; 
                simulation.alphaTarget(0.3).restart();
            }
            d.fx = d.x;
            d.fy = d.y;
        }

        function dragged(event, d) {
            d.fx = event.x;
            d.fy = event.y;
        }

        function dragended(event, d) {
            if (!event.active) simulation.alphaTarget(0);
            d.fx = null;
            d.fy = null;
        }

        function resetSimulation() {
            nodes.forEach(n => {
                n.fx = null;
                n.fy = null;
            });
            resetHighlight();
            tickCount = 0;
            simulation.alpha(1).restart();
        }

        function centerGraph() {
            const transform = d3.zoomIdentity
                .translate(window.innerWidth / 2, window.innerHeight / 2)
                .scale(1);
            svg.transition().duration(750).call(zoom.transform, transform);
            simulation.force("center", d3.forceCenter(window.innerWidth / 2, window.innerHeight / 2));
            tickCount = 0;
            simulation.alpha(0.3).restart();
        }

        function toggleGrouping() {
            isGrouped = !isGrouped;
            const btn = document.getElementById('groupBtn');
            
            resetHighlight();
            
            if (isGrouped) {
                btn.classList.add('active');
                btn.textContent = 'üì¶ –†–∞–∑–≥—Ä—É–ø–ø–∏—Ä–æ–≤–∞—Ç—å';
                
                // –î–æ–±–∞–≤–ª—è–µ–º —Å–∏–ª—ã –≥—Ä—É–ø–ø–∏—Ä–æ–≤–∫–∏
                simulation
                    .force("x", d3.forceX(d => groupPositions[d.concept].x).strength(0.3))
                    .force("y", d3.forceY(d => groupPositions[d.concept].y).strength(0.3))
                    .force("charge", d3.forceManyBody().strength(-200))
                    .force("collision", d3.forceCollide().radius(40));
            } else {
                btn.classList.remove('active');
                btn.textContent = 'üì¶ –ì—Ä—É–ø–ø–∏—Ä–æ–≤–∞—Ç—å';
                
                // –£–±–∏—Ä–∞–µ–º —Å–∏–ª—ã –≥—Ä—É–ø–ø–∏—Ä–æ–≤–∫–∏
                simulation
                    .force("x", null)
                    .force("y", null)
                    .force("charge", d3.forceManyBody().strength(-350))
                    .force("collision", d3.forceCollide().radius(45))
                    .force("center", d3.forceCenter(window.innerWidth / 2, window.innerHeight / 2));
            }
            tickCount = 0;
            simulation.alpha(0.5).restart();
        }

        window.addEventListener('resize', () => {
            const newWidth = window.innerWidth;
            const newHeight = window.innerHeight;
            svg.attr("width", newWidth).attr("height", newHeight);
            
            // –ü–µ—Ä–µ—Å—á–∏—Ç—ã–≤–∞–µ–º –ø–æ–∑–∏—Ü–∏–∏ –≥—Ä—É–ø–ø
            const newSpacingX = newWidth / (cols + 1);
            const newSpacingY = newHeight / (rows + 1);
            philosopherNames.forEach((phil, i) => {
                const col = i % cols;
                const row = Math.floor(i / cols);
                groupPositions[phil] = {
                    x: newSpacingX * (col + 1),
                    y: newSpacingY * (row + 1)
                };
            });
            
            if (isGrouped) {
                simulation
                    .force("x", d3.forceX(d => groupPositions[d.concept].x).strength(0.3))
                    .force("y", d3.forceY(d => groupPositions[d.concept].y).strength(0.3));
            } else {
                simulation.force("center", d3.forceCenter(newWidth / 2, newHeight / 2));
            }
            
            simulation.alpha(0.3).restart();
        });
        
        function showDetailModal(conceptData) {
            const modal = document.getElementById('detailModal');
            const overlay = document.getElementById('modalOverlay');
            const content = document.getElementById('modalContent');
            
            // –ü–æ–ª—É—á–∞–µ–º —Ä—É–±—Ä–∏–∫–∏ —ç—Ç–æ–π –∫–æ–Ω—Ü–µ–ø—Ü–∏–∏
            const conceptRubrics = conceptToRubrics[conceptData.id] || [];
            
            let html = `
                <h2>${conceptData.label}</h2>
                <div class="philosopher-tag" style="background: ${philosopherConcepts[conceptData.concept].color}">
                    ${conceptData.concept}
                </div>
                <div class="description">${conceptData.extendedDescription}</div>
            `;
            
            if (conceptRubrics.length > 0) {
                // –ù–∞—Ö–æ–¥–∏–º –¥–∞–Ω–Ω—ã–µ —Ä—É–±—Ä–∏–∫
                const rubricDataArray = conceptRubrics.map(rubricId => 
                    rubrics.find(r => r.id === rubricId)
                ).filter(r => r !== undefined);
                
                rubricDataArray.forEach(rubricData => {
                    // –ù–∞—Ö–æ–¥–∏–º –¥—Ä—É–≥–∏–µ –∫–æ–Ω—Ü–µ–ø—Ü–∏–∏ –∏–∑ —Ç–æ–π –∂–µ —Ä—É–±—Ä–∏–∫–∏
                    const relatedConcepts = nodes.filter(n => {
                        const nRubrics = conceptToRubrics[n.id] || [];
                        return nRubrics.includes(rubricData.id) && n.id !== conceptData.id;
                    });
                    
                    html += `
                        <div class="rubric-section">
                            <div class="rubric-title">üìö –†—É–±—Ä–∏–∫–∞: ${rubricData.name}</div>
                            <div class="rubric-description">${rubricData.description}</div>
                            
                            ${relatedConcepts.length > 0 ? `
                                <div class="related-concepts">
                                    <div class="related-title">–¢–∞–∫–∂–µ –≤ —ç—Ç–æ–π —Ä—É–±—Ä–∏–∫–µ (${relatedConcepts.length}):</div>
                                    ${relatedConcepts.slice(0, 10).map(c => `
                                        <div class="concept-item" onclick="closeDetailModal(); setTimeout(() => showDetailModal(nodes.find(n => n.id === '${c.id}')), 100);">
                                            <div class="concept-color" style="background: ${philosopherConcepts[c.concept].color}"></div>
                                            <div class="concept-name">${c.label}</div>
                                            <div class="concept-philosopher">${c.concept}</div>
                                        </div>
                                    `).join('')}
                                    ${relatedConcepts.length > 10 ? `<div style="font-size: 10px; color: #95a5a6; margin-top: 8px;">–∏ –µ—â—ë ${relatedConcepts.length - 10}...</div>` : ''}
                                </div>
                            ` : ''}
                        </div>
                    `;
                });
            } else {
                html += `<div class="rubric-section">
                    <div class="rubric-description" style="color: #95a5a6;">
                        –≠—Ç–∞ –∫–æ–Ω—Ü–µ–ø—Ü–∏—è –ø–æ–∫–∞ –Ω–µ –æ—Ç–Ω–µ—Å–µ–Ω–∞ –∫ –∫–∞–∫–æ–π-–ª–∏–±–æ —Ä—É–±—Ä–∏–∫–µ.
                    </div>
                </div>`;
            }
            
            content.innerHTML = html;
            modal.classList.add('show');
            overlay.classList.add('show');
        }
        
        function closeDetailModal() {
            const modal = document.getElementById('detailModal');
            const overlay = document.getElementById('modalOverlay');
            const content = document.getElementById('modalContent');
            
            // –û—á–∏—â–∞–µ–º —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ –¥–ª—è —É–¥–∞–ª–µ–Ω–∏—è –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤
            content.innerHTML = '';
            
            modal.classList.remove('show');
            overlay.classList.remove('show');
        }
        
        // –ó–∞–∫—Ä—ã—Ç–∏–µ –ø–æ –∫–ª–∏–∫—É –Ω–∞ overlay
        document.getElementById('modalOverlay').addEventListener('click', closeDetailModal);
        
        // –ó–∞–∫—Ä—ã—Ç–∏–µ –ø–æ Escape
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                closeDetailModal();
            }
        });
        
        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º —Ñ–∏–ª—å—Ç—Ä—ã –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ
        console.log("–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –≥—Ä–∞—Ñ–∞:", nodes.length, "—É–∑–ª–æ–≤,", links.length, "—Å–≤—è–∑–µ–π");
        initFilters();
        updateFilterStats();
        
        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –Ω–æ–≤—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏
        initPathFinder();
        
        // –í–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ –ø–∞–Ω–µ–ª–µ–π
        restorePanelStates();
        
        // –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –ø–æ—Å–ª–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è —Å–∏–º—É–ª—è—Ü–∏–∏
        simulation.on("end", () => {
            console.log("–°–∏–º—É–ª—è—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞. –ó–∞–ø—É—Å—Ç–∏—Ç–µ –∞–Ω–∞–ª–∏–∑ –≤—Ä—É—á–Ω—É—é.");
        });
        
        // –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –¥–ª—è —á–µ–∫–±–æ–∫—Å–æ–≤
        document.getElementById('useWeightsToggle').checked = useWeightedPaths;
        document.getElementById('respectDirectionToggle').checked = respectDirection;
        
        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã—Ö —Ä–∞–¥–∏—É—Å–æ–≤
        saveOriginalRadii();
        
        console.log("–ì—Ä–∞—Ñ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–Ω–æ–ø–∫–∏ –¥–ª—è –∑–∞–ø—É—Å–∫–∞ –∞–Ω–∞–ª–∏–∑–∞.");
        console.log("–¢–µ–∫—É—â–∏–π —Ä–µ–∂–∏–º: –≤–µ—Å–∞ -", useWeightedPaths ? "–í–ö–õ" : "–í–´–ö–õ", 
                    ", –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–Ω–æ—Å—Ç—å -", respectDirection ? "–í–ö–õ" : "–í–´–ö–õ");
        
    </script>
</body>
</html>
