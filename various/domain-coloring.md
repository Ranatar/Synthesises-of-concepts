# Метод Domain Coloring: Техники и схемы раскраски для визуализации функций комплексного переменного

## Введение

Domain coloring — это мощный метод визуализации функций комплексного переменного, позволяющий отображать на двумерной плоскости четырехмерные данные (два измерения входного комплексного числа и два измерения выходного комплексного числа). Метод основан на присвоении цвета каждой точке комплексной плоскости в зависимости от значения функции в этой точке.

В этом документе представлены различные схемы раскраски с соответствующими формулами и алгоритмами реализации.

## Основные понятия

Для функции комплексного переменного $f(z)$, где $z = x + iy$, значение $f(z)$ также является комплексным числом, которое можно представить в различных формах:
- Алгебраическая форма: $f(z) = u(x,y) + iv(x,y)$
- Полярная форма: $f(z) = |f(z)|e^{i\arg f(z)}$, где $|f(z)|$ — модуль (магнитуда), $\arg f(z)$ — аргумент (фаза)

## 1. Классическая HSV-схема раскраски

**Принцип**: Используется цветовая модель HSV (Hue-Saturation-Value):
- Оттенок (Hue) представляет аргумент функции
- Насыщенность (Saturation) обычно фиксированная (100%)
- Яркость (Value) представляет модуль функции

**Формула**:
```
H = (arg(f(z)) / (2π)) * 360° (оттенок в градусах)
S = 1.0 (максимальная насыщенность)
V = 1 - exp(-|f(z)|) (нормализованная яркость)
```

**Алгоритм**:
1. Выбрать область комплексной плоскости для визуализации
2. Для каждой точки z в этой области:
   - Вычислить значение f(z)
   - Вычислить arg(f(z)) и |f(z)|
   - Преобразовать arg(f(z)) в оттенок (0-360°)
   - Преобразовать |f(z)| в яркость (0-1)
   - Преобразовать HSV в RGB и закрасить соответствующий пиксель

## 2. Улучшенная HSV-схема с периодической яркостью

**Принцип**: Добавление периодических изменений яркости в зависимости от модуля для лучшего отображения уровней функции.

**Формула**:
```
H = (arg(f(z)) / (2π)) * 360°
S = 1.0
V = (1 - exp(-|f(z)|)) * (0.5 + 0.5 * sin(2π * |f(z)|))
```

**Алгоритм**: 
Аналогичен классической HSV-схеме, но с модифицированной формулой для яркости, которая включает синусоидальную модуляцию, зависящую от модуля функции.

## 3. Логарифмическая схема для функций с большим диапазоном значений

**Принцип**: Использование логарифма модуля для лучшего отображения функций с большим диапазоном значений.

**Формула**:
```
H = (arg(f(z)) / (2π)) * 360°
S = 1.0
V = 1 - exp(-a * log(1 + |f(z)|))
```
где a — параметр масштабирования (обычно от 0.1 до 1.0).

**Алгоритм**:
Модифицированная версия классической схемы с применением логарифмического масштабирования для модуля функции.

## 4. Схема с координатной сеткой (Grid-enhanced)

**Принцип**: Наложение координатной сетки на раскраску для лучшего понимания структуры отображения.

**Формула**:
```
H = (arg(f(z)) / (2π)) * 360°
S = 1.0 - grid_factor(f(z))
V = 1 - exp(-|f(z)|)

Где grid_factor(f(z)) = max(
  0.4 * (1 - min(1, 10 * min(|mod(Re(f(z)), 1) - 0.5|, |mod(Im(f(z)), 1) - 0.5|))),
  0
)
```

**Алгоритм**:
1. Вычислить базовую HSV-раскраску как в классической схеме
2. Модифицировать насыщенность в зависимости от близости к линиям сетки:
   - Линии сетки соответствуют целым значениям действительной и мнимой частей f(z)
   - Чем ближе к линии сетки, тем ниже насыщенность (что создает эффект белых линий)

## 5. Полярная координатная сетка

**Принцип**: Наложение полярной координатной сетки (круги и лучи) на раскраску.

**Формула**:
```
H = (arg(f(z)) / (2π)) * 360°
S = 1.0 - polar_grid_factor(f(z))
V = 1 - exp(-|f(z)|)

Где polar_grid_factor(f(z)) = max(
  0.4 * (1 - min(1, 10 * min(|mod(|f(z)|, 1) - 0.5|, |mod(arg(f(z))/(π/6), 1) - 0.5|))),
  0
)
```

**Алгоритм**:
Аналогичен схеме с декартовой сеткой, но линии сетки соответствуют:
- Окружностям с целыми радиусами (постоянный модуль)
- Лучам с шагом π/6 радиан (постоянный аргумент)

## 6. Метод с подчеркиванием особенностей (Enhanced Phase Portrait)

**Принцип**: Особое выделение полюсов, нулей и других особенностей функции.

**Формула**:
```
H = (arg(f(z)) / (2π)) * 360°
S = 1.0
V = 1 - exp(-a * |f(z)|^b)
```
где:
- a — параметр масштабирования
- b — параметр контрастности (b < 1 подчеркивает нули, b > 1 подчеркивает полюса)

**Алгоритм**:
Использование степенной функции с параметром b для управления контрастностью:
- Для выделения нулей: использовать b ≈ 0.2–0.5
- Для выделения полюсов: использовать b ≈ 2–5

## 7. Схема с фазовыми линиями (Phase Lines)

**Принцип**: Выделение линий с постоянным аргументом (фазой).

**Формула**:
```
H = (arg(f(z)) / (2π)) * 360°
S = 1.0
V = (1 - exp(-|f(z)|)) * (0.7 + 0.3 * cos(n * arg(f(z))))
```
где n — количество фазовых линий (обычно кратно 4).

**Алгоритм**:
Модуляция яркости с помощью косинуса аргумента, умноженного на n, создает видимые линии постоянной фазы.

## 8. Схема с модульными линиями (Modulus Lines)

**Принцип**: Выделение линий с постоянным модулем (концентрические окружности в области значений).

**Формула**:
```
H = (arg(f(z)) / (2π)) * 360°
S = 1.0
V = (1 - exp(-|f(z)|)) * (0.7 + 0.3 * cos(2π * log(|f(z)|)))
```

**Алгоритм**:
Логарифмирование модуля перед применением косинуса создает равноотстоящие линии в логарифмическом масштабе, что подчеркивает как малые, так и большие значения модуля.

## 9. Двойная периодическая схема (Double Periodic)

**Принцип**: Комбинирование периодичности по модулю и аргументу.

**Формула**:
```
H = (arg(f(z)) / (2π)) * 360°
S = 0.8 + 0.2 * cos(2π * log(1 + |f(z)|))
V = 0.9 * (1 - exp(-|f(z)|)) * (0.7 + 0.3 * cos(10 * arg(f(z))))
```

**Алгоритм**:
Одновременная модуляция насыщенности и яркости с разными частотами для создания сложного узора, подчеркивающего структуру функции.

## 10. Метод конформного отображения сетки (Conformal Grid)

**Принцип**: Визуализация того, как функция искажает регулярную сетку.

**Формула**:
```
z = x + iy
w = f(z)
grid_x = sin²(π * mod(Re(w), 1))
grid_y = sin²(π * mod(Im(w), 1))
grid_factor = min(grid_x, grid_y)

H = (arg(f(z)) / (2π)) * 360°
S = 1.0
V = min(1.0, 0.5 + 0.5 * (1 - grid_factor)^3)
```

**Алгоритм**:
1. Вычислить базовую HSV-раскраску
2. Применить функцию sin² для создания периодического рисунка сетки
3. Использовать минимальное значение для выделения линий сетки
4. Модифицировать яркость для создания четких линий

## 11. Схема "терма" (Thermal)

**Принцип**: Используется цветовая палитра, напоминающая тепловизор.

**Формула**:
```
t = (1 - exp(-|f(z)|)) * (mod(arg(f(z))/(π), 2) - 1)^2
R = 3 * t * (1 - t)^2
G = 3 * t^2 * (1 - t)
B = t^3
```

**Алгоритм**:
Вместо HSV используется специальная параметризация, где t — комбинированный параметр, зависящий от модуля и аргумента. Формулы для RGB создают плавный переход от черного через красный, желтый, белый к синему.

## 12. Схема с выделением критических точек (Critical Points Enhanced)

**Принцип**: Особое выделение критических точек функции (где f'(z) = 0).

**Формула**:
```
df = аппроксимация f'(z)
highlight = exp(-100 * |df|^2)

H = (arg(f(z)) / (2π)) * 360°
S = 1.0 - 0.8 * highlight
V = 1 - exp(-|f(z)|) + 0.3 * highlight
```

**Алгоритм**:
1. Вычислить приближенное значение производной f'(z) (можно использовать численное дифференцирование)
2. Вычислить коэффициент highlight, который близок к 1 вблизи критических точек и близок к 0 вдали от них
3. Модифицировать насыщенность и яркость для выделения критических точек (обычно белым цветом)

**Подалгоритм вычисления производной f'(z)**:

Существует несколько способов вычисления производной функции комплексного переменного:

1. **Аналитический метод** (если функция задана аналитически):
   - Использовать стандартные правила дифференцирования
   - Например, для полиномов, тригонометрических, экспоненциальных функций применяются известные формулы

2. **Метод конечных разностей**:
   ```
   h = малое комплексное число (например, 1e-6 или 1e-6 * (1 + i))
   f'(z) ≈ (f(z + h) - f(z)) / h  // односторонняя разность
   f'(z) ≈ (f(z + h) - f(z - h)) / (2h)  // центральная разность (более точная)
   ```

3. **Метод Коши** (контурный интеграл):
   ```
   f'(z) = (1/(2πi)) ∮ f(ζ)/(ζ-z)² dζ
   ```
   Для численного вычисления:
   ```
   r = малое положительное число (радиус окружности)
   n = количество точек на окружности (например, 16 или 32)
   f'(z) ≈ (1/n) * Σ[k=0..n-1] f(z + r*e^(2πik/n)) * e^(-2πik/n) / r
   ```

4. **Метод комплексного шага** (для аналитических функций):
   ```
   f'(z) ≈ Im(f(z + ih)) / h, где h - малое положительное действительное число
   ```

Для схемы с выделением критических точек обычно достаточно использовать метод конечных разностей с центральной разностью, так как он обеспечивает хороший баланс между точностью и вычислительной сложностью.

## 13. Схема "неоновых контуров" (Neon Contours)

**Принцип**: Создание эффекта светящихся неоновых контуров по линиям постоянного модуля и аргумента.

**Формула**:
```
mod_contour = exp(-50 * min(mod(log(|f(z)|), 0.5), 0.5)^2)
arg_contour = exp(-50 * min(mod(arg(f(z))/(π/4), 1), 0.5)^2)

H = (arg(f(z)) / (2π)) * 360°
S = 1.0 - 0.8 * max(mod_contour, arg_contour)
V = (1 - exp(-|f(z)|)) + 0.5 * max(mod_contour, arg_contour)
```

**Алгоритм**:
1. Вычислить коэффициенты близости к контурам постоянного модуля и аргумента
2. Модифицировать насыщенность и яркость для создания эффекта свечения вдоль этих контуров

## 14. Схема со стереографической проекцией (Stereographic Projection)

**Принцип**: Лучшая визуализация окрестности бесконечности с помощью стереографической проекции.

**Формула**:
```
w = f(z)
w_stereo = w / (1 + |w|^2)  // стереографическая проекция

H = (arg(w) / (2π)) * 360°
S = 1.0
V = 0.5 + 0.5 * |w_stereo|
```

**Алгоритм**:
1. Применить стереографическую проекцию к значению функции
2. Использовать модуль проецированного значения для определения яркости
3. Аргумент оригинального значения функции по-прежнему используется для оттенка

## 15. Метод с аналитическим ландшафтом (Analytic Landscape)

**Принцип**: Комбинация domain coloring с идеей построения трехмерной поверхности.

**Формула**:
```
height = log(1 + |f(z)|)
gradient = |∇height|
shading = 0.6 + 0.4 * (1 - min(1, gradient))

H = (arg(f(z)) / (2π)) * 360°
S = 1.0
V = shading * (1 - exp(-|f(z)|))
```

**Алгоритм**:
1. Вычислить «высоту» как логарифм модуля функции
2. Вычислить приближенный градиент этой высоты
3. Использовать градиент для имитации освещения трехмерной поверхности
4. Модифицировать яркость в соответствии с этим освещением

**Подалгоритм вычисления градиента высоты**:

Градиент высоты в точке z = x + iy представляет собой вектор ∇height = (∂height/∂x, ∂height/∂y), показывающий направление наиболее быстрого возрастания функции высоты.

1. **Аналитический метод** (если функция задана аналитически):
   
   Для height = log(1 + |f(z)|):
   ```
   |f(z)| = √(u² + v²), где f(z) = u(x,y) + iv(x,y)
   
   ∂|f(z)|/∂x = (u*∂u/∂x + v*∂v/∂x) / |f(z)|
   ∂|f(z)|/∂y = (u*∂u/∂y + v*∂v/∂y) / |f(z)|
   
   ∂height/∂x = ∂log(1 + |f(z)|)/∂x = 1/(1 + |f(z)|) * ∂|f(z)|/∂x
   ∂height/∂y = ∂log(1 + |f(z)|)/∂y = 1/(1 + |f(z)|) * ∂|f(z)|/∂y
   
   ∇height = (∂height/∂x, ∂height/∂y)
   |∇height| = √((∂height/∂x)² + (∂height/∂y)²)
   ```

2. **Численный метод** (метод конечных разностей):
   ```
   h = малый шаг (например, 1e-6)
   
   ∂height/∂x ≈ (height(x+h, y) - height(x-h, y)) / (2*h)
   ∂height/∂y ≈ (height(x, y+h) - height(x, y-h)) / (2*h)
   
   |∇height| ≈ √((∂height/∂x)² + (∂height/∂y)²)
   ```

3. **Оптимизированный численный метод** (для функции height = log(1 + |f(z)|)):
   ```
   h = малый шаг (например, 1e-6)
   
   f_x_plus = f(x+h, y)
   f_x_minus = f(x-h, y)
   f_y_plus = f(x, y+h)
   f_y_minus = f(x, y-h)
   
   ∂height/∂x ≈ (log(1 + |f_x_plus|) - log(1 + |f_x_minus|)) / (2*h)
   ∂height/∂y ≈ (log(1 + |f_y_plus|) - log(1 + |f_y_minus|)) / (2*h)
   
   |∇height| ≈ √((∂height/∂x)² + (∂height/∂y)²)
   ```

4. **Упрощенный подход с использованием свойств аналитических функций**:
   
   Для аналитических функций можно использовать связь между модулем функции и её производной:
   ```
   ∇log|f(z)| = Re(f'(z)/f(z)) * (1, 0) + Im(f'(z)/f(z)) * (0, 1)
   
   И тогда для height = log(1 + |f(z)|):
   ∇height = |f(z)|/(1 + |f(z)|) * ∇log|f(z)|
   ```

В визуализации обычно используется численный метод или оптимизированный численный метод, так как они работают для любых функций комплексного переменного и достаточно эффективны.

## 16. Схема "цветной рельеф" (Color Relief)

**Принцип**: Использование цвета для отображения аргумента и яркостного рельефа для модуля.

**Формула**:
```
mod_scaled = 2 * (1 - exp(-|f(z)|/2))
mod_relief = mod_scaled - floor(mod_scaled)
brightness = 0.4 + 0.6 * (mod_relief < 0.5 ? 2 * mod_relief : 2 * (1 - mod_relief))

H = (arg(f(z)) / (2π)) * 360°
S = 1.0
V = brightness
```

**Алгоритм**:
Создание ступенчатого рельефа по модулю функции, выраженного через яркость, в сочетании с плавным изменением цвета по аргументу.

## 17. Метод с доминантной фазой (Dominant Phase)

**Принцип**: Подчеркивание структуры аргумента (фазы) функции.

**Формула**:
```
phase_dominance = 0.7 + 0.3 * cos(n * arg(f(z)))
mod_factor = 0.8 * (1 - exp(-|f(z)|))

H = (arg(f(z)) / (2π)) * 360°
S = 1.0
V = mod_factor * phase_dominance
```
где n — количество секторов (обычно 8 или 16).

**Алгоритм**:
Создание четко выраженных секторов по аргументу функции, с плавным изменением яркости внутри каждого сектора.

## 18. Метод с выделением мероморфной структуры (Meromorphic Structure)

**Принцип**: Особое выделение полюсов и нулей мероморфных функций.

**Формула**:
```
pole_factor = 1 - exp(-0.1/max(|f(z)|, 0.001))  // выделение полюсов
zero_factor = 1 - exp(-0.1*min(|f(z)|, 10))     // выделение нулей
highlight = max(pole_factor, zero_factor)

H = (arg(f(z)) / (2π)) * 360°
S = 1.0 - 0.5 * highlight
V = 0.5 + 0.5 * (1 - exp(-|f(z)|)) + 0.3 * highlight
```

**Алгоритм**:
1. Вычислить факторы близости к полюсам и нулям
2. Объединить их для создания общего фактора выделения особенностей
3. Модифицировать насыщенность и яркость для выделения этих особенностей

## 19. Схема с градиентным отображением (Gradient Mapping)

**Принцип**: Использование специально подобранной градиентной карты для модуля и аргумента.

**Формула**:
```
// Для примера, использование трехцветного градиента
arg_norm = (arg(f(z)) / (2π)) % 1.0
mod_norm = min(|f(z)|/5, 1.0)

Если arg_norm < 0.33:
  H = 240 - 240 * (arg_norm / 0.33)  // от синего к красному
Иначе если arg_norm < 0.67:
  H = 0 + 120 * ((arg_norm - 0.33) / 0.34)  // от красного к зеленому
Иначе:
  H = 120 + 120 * ((arg_norm - 0.67) / 0.33)  // от зеленого к синему

S = 0.8 + 0.2 * mod_norm
V = 0.5 + 0.5 * mod_norm
```

**Алгоритм**:
Использование кусочно-заданной функции для оттенка создает более контрастную цветовую схему, а модуль влияет на насыщенность и яркость.

## 20. Схема "кольца Сатурна" (Saturn Rings)

**Принцип**: Создание концентрических колец переменной интенсивности по модулю.

**Формула**:
```
log_mod = log(1 + |f(z)|)
ring_factor = 0.7 + 0.3 * cos(2π * log_mod * 2)
ray_factor = 0.9 + 0.1 * cos(arg(f(z)) * 16)

H = (arg(f(z)) / (2π)) * 360°
S = 0.9
V = (1 - exp(-|f(z)|)) * ring_factor * ray_factor
```

**Алгоритм**:
Комбинация модуляции яркости по логарифму модуля (кольца) и по аргументу (лучи) создает эффект, напоминающий планету с кольцами.

## Рекомендации по реализации

1. **Предварительная обработка**:
   - Определить границы отображаемой области комплексной плоскости
   - Выбрать разрешение (количество пикселей) для изображения
   - Решить, как обрабатывать особые точки функции (полюса, точки ветвления)

2. **Оптимизация вычислений**:
   - Использовать эффективные алгоритмы для вычисления комплексных функций
   - Применять параллельные вычисления по возможности
   - Кэшировать результаты при многократном вычислении одних и тех же значений

3. **Постобработка изображения**:
   - Применять сглаживание для устранения артефактов дискретизации
   - Настраивать параметры схемы для лучшей визуализации конкретной функции
   - Экспериментировать с параметрами схем для получения наиболее информативного изображения

4. **Интерактивность**:
   - Реализовать возможность масштабирования и перемещения по комплексной плоскости
   - Обеспечить быстрое переключение между различными схемами раскраски
   - Реализовать интерактивную настройку параметров схемы

## 21. Рациональная HSL-схема (Rational HSL)

**Принцип**: Использование рациональных функций от модуля и аргумента для управления компонентами HSL.

**Формула**:
```
mod_rational = |f(z)| / (1 + |f(z)|)  // нормализация модуля в диапазон [0, 1)
arg_norm = (arg(f(z)) / (2π)) % 1.0

H = arg_norm * 360°
S = mod_rational / (0.2 + mod_rational)  // рациональная функция для насыщенности
L = 0.5 * (1 + mod_rational / (0.5 + mod_rational))  // рациональная функция для яркости
```

**Алгоритм**:
1. Вычислить рациональную нормализацию модуля функции
2. Использовать дробно-рациональные функции для вычисления насыщенности и яркости
3. Преобразовать HSL в RGB для отображения

Рациональные функции обеспечивают плавное нарастание параметров с асимптотическим приближением к предельным значениям, что делает эту схему особенно полезной для функций с большим диапазоном значений модуля.

## 22. Схема с аффинным преобразованием модуля (Affine Modulus)

**Принцип**: Применение различных аффинных преобразований к модулю в зависимости от его величины.

**Формула**:
```
log_mod = log(1 + |f(z)|)
mod_affine = если log_mod < 1:
                0.3 * log_mod
             иначе если log_mod < 2:
                0.3 + 0.4 * (log_mod - 1)
             иначе:
                0.7 + 0.3 * (log_mod - 2) / (1 + (log_mod - 2))

H = (arg(f(z)) / (2π)) * 360°
S = 1.0
V = mod_affine
```

**Алгоритм**:
1. Логарифмировать модуль для сжатия диапазона
2. Применить кусочно-заданную аффинную функцию для трех диапазонов модуля
3. Использовать результат для яркости, сохраняя стандартное отображение аргумента на оттенок

Это позволяет чётко различать три диапазона значений модуля функции, что полезно для анализа поведения функции в различных областях.

## 23. "Фрактальная" схема для функций с полюсами (Fractal Poles)

**Принцип**: Создание фрактальных узоров вблизи полюсов функции.

**Формула**:
```
inv_mod = min(1 / |f(z)|, 10)  // ограниченная обратная величина модуля
spiral_factor = 0.5 + 0.5 * cos(2π * log(1 + inv_mod) + arg(f(z)))

H = (arg(f(z)) / (2π)) * 360°
S = 1.0 - 0.3 * spiral_factor
V = 0.4 + 0.6 * (1 - exp(-|f(z)|)) * (1 - 0.3 * spiral_factor)
```

**Алгоритм**:
1. Рассчитать обратную величину модуля (с ограничением для предотвращения деления на ноль)
2. Создать спиральный узор, зависящий от логарифма обратного модуля и аргумента
3. Модулировать насыщенность и яркость спиральным узором

Эта схема создает спиральные узоры вокруг полюсов, напоминающие фрактальные структуры, что визуально подчеркивает их расположение и порядок.

## 24. Схема с двойным оттенком (Dual Hue)

**Принцип**: Использование двух оттенков, зависящих от действительной и мнимой частей функции.

**Формула**:
```
re_norm = 0.5 + 0.5 * tanh(Re(f(z)))  // нормализация действительной части в [0, 1]
im_norm = 0.5 + 0.5 * tanh(Im(f(z)))  // нормализация мнимой части в [0, 1]

H_re = re_norm * 360°
H_im = im_norm * 360°

blend = 0.5 + 0.5 * sin(π * |f(z)| / (1 + |f(z)|))
H = H_re * (1 - blend) + H_im * blend

S = 0.8 + 0.2 * min(re_norm, im_norm)
V = 0.9 * (1 - exp(-|f(z)|))
```

**Алгоритм**:
1. Нормализовать действительную и мнимую части функции с помощью гиперболического тангенса
2. Вычислить два оттенка на основе нормализованных компонент
3. Смешать оттенки с весом, зависящим от модуля функции
4. Настроить насыщенность и яркость для лучшей визуализации

Эта схема позволяет визуально различать как изменения аргумента, так и соотношение действительной и мнимой частей функции.

## 25. Схема с выделением особых значений (Special Values)

**Принцип**: Особое выделение определенных значений функции, например, целых чисел или чисел на единичной окружности.

**Формула**:
```
// Выделение целых значений
re_integer = exp(-50 * min(|Re(f(z)) - round(Re(f(z)))|, 0.5)^2)
im_integer = exp(-50 * min(|Im(f(z)) - round(Im(f(z)))|, 0.5)^2)
integer_highlight = max(re_integer, im_integer)

// Выделение значений на единичной окружности
unit_circle = exp(-50 * (||f(z)| - 1|)^2)

// Выделение нулевого значения
zero_highlight = exp(-|f(z)|^2 / 0.01)

// Комбинирование выделений
highlight = max(integer_highlight, unit_circle, zero_highlight)

H = (arg(f(z)) / (2π)) * 360°
S = 1.0 - 0.8 * highlight
V = 0.5 + 0.5 * (1 - exp(-|f(z)|)) + 0.3 * highlight
```

**Алгоритм**:
1. Вычислить функции близости к целым значениям действительной и мнимой частей
2. Вычислить функцию близости к единичной окружности и к нулю
3. Объединить все функции близости для создания общего фактора выделения
4. Модифицировать насыщенность и яркость для выделения особых значений

Эта схема позволяет наглядно видеть, где функция принимает особые значения: целые числа, числа на единичной окружности и ноль.

## 26. Многослойная схема смешивания (Multi-layer Blend)

**Принцип**: Создание сложного цветового пространства путем смешивания нескольких слоев раскраски.

**Формула**:
```
// Слой 1: стандартный HSV
H1 = (arg(f(z)) / (2π)) * 360°
S1 = 1.0
V1 = 1 - exp(-|f(z)|)

// Слой 2: периодический по модулю
H2 = (log(1 + |f(z)|) % 1) * 360°
S2 = 0.8
V2 = 0.7 + 0.3 * cos(2π * log(1 + |f(z)|))

// Слой 3: производная
df = аппроксимация f'(z)
H3 = (arg(df) / (2π)) * 360°
S3 = 0.9
V3 = 1 - exp(-|df|)

// Смешивание слоев
weight1 = 0.6
weight2 = 0.3
weight3 = 0.1

H = (H1 * weight1 + H2 * weight2 + H3 * weight3) % 360°
S = S1 * weight1 + S2 * weight2 + S3 * weight3
V = V1 * weight1 + V2 * weight2 + V3 * weight3
```

**Алгоритм**:
1. Создать три независимых слоя раскраски с разными принципами
2. Смешать компоненты HSV с фиксированными или динамическими весами
3. Преобразовать результирующие HSV в RGB для отображения

Этот подход создает богатые, сложные визуализации, которые одновременно отображают несколько аспектов функции.

## 27. Метод подчеркивания аналитической структуры (Analytic Structure)

**Принцип**: Подчеркивание структуры, характерной для аналитических функций (линий уровня, сингулярностей).

**Формула**:
```
// Линии уровня по модулю (логарифмическая шкала)
mod_lines = 0.7 + 0.3 * cos(2π * log(1 + |f(z)|) * 2)

// Лучи постоянного аргумента
arg_rays = 0.7 + 0.3 * cos(arg(f(z)) * 8)

// Выделение особенностей производной
df = аппроксимация f'(z)
d2f = аппроксимация f''(z)
wronskian = |df|^2 - f(z) * d2f
structure = exp(-10 * |wronskian|) / (0.1 + |f(z)|^2)

H = (arg(f(z)) / (2π)) * 360°
S = 0.9 - 0.5 * structure
V = (0.3 + 0.7 * (1 - exp(-|f(z)|))) * mod_lines * arg_rays + 0.2 * structure
```

**Алгоритм**:
1. Создать модуляцию яркости по логарифму модуля и по аргументу
2. Вычислить производные и вронскиан для выделения особенностей аналитической структуры
3. Комбинировать все компоненты для создания полной картины

Этот метод позволяет визуализировать тонкие детали аналитической структуры функции, такие как порядок полюсов, нулей и критических точек.

## 28. Интерференционная схема (Interference)

**Принцип**: Создание узоров, напоминающих интерференционные полосы в оптике.

**Формула**:
```
// Фазовые компоненты
phase1 = (arg(f(z)) / (2π)) % 1.0
phase2 = (log(1 + |f(z)|) / (2π)) % 1.0

// Интерференционный узор
interference = 0.5 + 0.5 * cos(2π * (phase1 - phase2) * 8)

// Модуляция интенсивности по модулю
intensity = 1 - exp(-|f(z)|)

H = ((phase1 + phase2) / 2) * 360°
S = 1.0 - 0.7 * interference
V = 0.3 + 0.7 * intensity * (0.5 + 0.5 * interference)
```

**Алгоритм**:
1. Вычислить две фазовые компоненты: нормализованный аргумент и нормализованный логарифм модуля
2. Создать интерференционный узор на основе разности фаз
3. Использовать среднюю фазу для оттенка, а интерференционный узор для модуляции насыщенности и яркости

Эта схема создает сложные волновые узоры, напоминающие интерференцию волн, что может помочь визуализировать фазовые соотношения внутри функции.

## 29. Схема модификации градиента по Собелю (Sobel Gradient Enhancement)

**Принцип**: Использование оператора Собеля для выделения областей быстрого изменения функции.

**Формула**:
```
// Вычисление градиента по Собелю
Gx = (f(z+h) - f(z-h)) / (2h)  // аппроксимация градиента по x
Gy = (f(z+ih) - f(z-ih)) / (2ih)  // аппроксимация градиента по y
gradient_magnitude = |Gx| + |Gy|  // L1-норма градиента

// Масштабирование градиента для визуализации
gradient_scaled = 1 - exp(-gradient_magnitude)

H = (arg(f(z)) / (2π)) * 360°
S = 0.6 + 0.4 * gradient_scaled
V = 0.4 + 0.6 * (1 - exp(-|f(z)|)) * (0.7 + 0.3 * gradient_scaled)
```

**Алгоритм**:
1. Вычислить аппроксимацию градиента функции по x и y с использованием конечных разностей
2. Рассчитать магнитуду градиента, используя L1-норму для повышения контраста
3. Применить градиент для модификации насыщенности и яркости

Эта схема особенно хорошо выделяет области, где функция быстро меняется, например, вблизи ветвей разреза или критических точек.

## 30. Топографическая схема (Topographic)

**Принцип**: Визуализация функции в виде топографической карты.

**Формула**:
```
// Высота как функция модуля
height = log(1 + |f(z)|)

// Контурные линии высоты
contour_lines = 0.5 + 0.5 * cos(2π * height * n)  // n - количество контурных линий на единицу высоты

// Имитация освещения склонов
gradient = |∇height|
slope_factor = max(0, 1 - gradient)  // пологие склоны светлее
direction = arg(∇height) / (2π)  // направление склона

H = (arg(f(z)) / (2π)) * 360°
S = 0.3 + 0.7 * slope_factor
V = 0.3 + 0.4 * (1 - exp(-|f(z)|)) + 0.3 * contour_lines
```

**Алгоритм**:
1. Вычислить "высоту" как логарифм модуля функции
2. Создать контурные линии по высоте с заданной частотой
3. Рассчитать градиент высоты для имитации освещения склонов
4. Комбинировать все компоненты, используя аргумент функции для оттенка

Эта схема создаёт визуализацию, напоминающую топографическую карту, где модуль функции представлен высотой, а аргумент — цветом местности.

## Заключение

Domain coloring — это мощный и гибкий метод визуализации функций комплексного переменного. Различные схемы раскраски позволяют подчеркивать разные аспекты этих функций: аргумент, модуль, критические точки, полюса, нули и другие особенности. Сочетание нескольких схем часто дает наиболее полное представление о поведении функции.

При выборе схемы раскраски следует руководствоваться как эстетическими соображениями, так и тем, какие аспекты функции необходимо подчеркнуть. Экспериментирование с параметрами схем и их комбинирование может привести к созданию новых, еще более информативных и эстетически привлекательных визуализаций.

## Сравнительная таблица схем раскраски

| Схема | Основной принцип | Лучше всего подходит для |
|-------|-----------------|--------------------------|
| 1. Классическая HSV | Оттенок по аргументу, яркость по модулю | Общая визуализация, базовое представление |
| 2. Улучшенная HSV с периодичностью | Дополнительная периодическая модуляция яркости | Функции с большим диапазоном модуля |
| 3. Логарифмическая | Логарифмическое масштабирование модуля | Функции с очень большим диапазоном значений |
| 4. Координатная сетка | Наложение декартовой сетки | Визуализация отображения координат |
| 5. Полярная сетка | Наложение полярной сетки | Функции с радиальной симметрией |
| 6. Подчеркивание особенностей | Выделение нулей и полюсов | Рациональные и мероморфные функции |
| 7. Фазовые линии | Выделение линий постоянного аргумента | Анализ аргумента функции |
| 8. Модульные линии | Выделение линий постоянного модуля | Анализ модуля функции |
| 9. Двойная периодическая | Периодичность по модулю и аргументу | Сложные аналитические функции |
| 10. Конформное отображение сетки | Визуализация искажения сетки | Анализ конформных отображений |
| 11. Терма | Тепловизорная палитра | Научная визуализация |
| 12. Выделение критических точек | Подсветка точек f'(z)=0 | Анализ производных и критических точек |
| 13. Неоновые контуры | Эффект светящихся линий уровня | Эстетическая визуализация |
| 14. Стереографическая проекция | Лучшее отображение окрестности бесконечности | Функции с особенностями на бесконечности |
| 15. Аналитический ландшафт | Имитация 3D-поверхности | Визуализация модуля как высоты |
| 16. Цветной рельеф | Ступенчатый рельеф по модулю | Визуализация уровней модуля |
| 17. Доминантная фаза | Подчеркивание структуры аргумента | Анализ фазовой структуры |
| 18. Мероморфная структура | Выделение полюсов и нулей | Мероморфные функции |
| 19. Градиентное отображение | Специальные градиентные карты | Эстетическая и научная визуализация |
| 20. Кольца Сатурна | Концентрические кольца с лучами | Функции с периодическими особенностями |
| 21. Рациональная HSL | Рациональные функции для компонент HSL | Функции с большим динамическим диапазоном |
| 22. Аффинное преобразование модуля | Кусочно-аффинные функции модуля | Разделение диапазонов значений функции |
| 23. Фрактальная для полюсов | Фрактальные узоры вблизи полюсов | Рациональные функции с полюсами |
| 24. Двойной оттенок | Разные оттенки для Re и Im | Анализ компонент комплексной функции |
| 25. Выделение особых значений | Подсветка важных значений функции | Изучение поведения вблизи особых точек |
| 26. Многослойное смешивание | Комбинирование нескольких схем | Комплексный анализ функции |
| 27. Аналитическая структура | Подчеркивание аналитических свойств | Глубокий анализ аналитических функций |
| 28. Интерференционная | Узоры, похожие на интерференцию | Визуализация фазовых отношений |
| 29. Модификация по Собелю | Выделение областей быстрого изменения | Поиск разрывов и особенностей |
| 30. Топографическая | Визуализация в виде карты рельефа | Визуализация, интуитивно понятная без подготовки |
